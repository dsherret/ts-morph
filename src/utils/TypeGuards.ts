// dprint-ignore-file
// -----------------------
// WARNING - DO NOT modify the "is" methods of the TypeGuards class directly. It is code generated by createTypeGuardsUtility.ts
//
// Note: This file is excluded from code coverage reports because it's automatically maintained (low risk).
// -----------------------

import * as compiler from "../compiler";
import { SyntaxKind } from "../typescript";
import { Structure } from "../structures";
import { KindToNodeMappings } from "../compiler";

/**
 * Type guards for checking the type of a node.
 */
export class TypeGuards {
    private constructor() {
    }

    /**
     * Gets if the node has an expression.
     * @param node - Node to check.
     */
    static hasExpression<T extends compiler.Node>(node: T): node is T & { getExpression(): compiler.Expression; } {
        // this method is manually maintained
        if ((node as any).getExpression == null)
            return false;
        return (node as any).getExpression() != null;
    }

    /**
     * Gets if the node has a name.
     * @param node - Node to check.
     */
    static hasName<T extends compiler.Node>(node: T): node is T & { getName(): string; getNameNode(): compiler.Node; } {
        // this method is manually maintained
        if ((node as any).getName == null)
            return false;
        return typeof (node as any).getName() === "string";
    }

    /**
     * Gets if the node has a body.
     * @param node - Node to check.
     */
    static hasBody<T extends compiler.Node>(node: T): node is T & { getBody(): compiler.Node; } {
        // this method is manually maintained
        if ((node as any).getBody == null)
            return false;
        return (node as any).getBody() != null;
    }

    /**
     * Creates a type guard for syntax kinds.
     */
    static is<TKind extends keyof KindToNodeMappings>(kind: TKind): (node: compiler.Node) => node is KindToNodeMappings[TKind] {
        return (node: compiler.Node): node is KindToNodeMappings[TKind] => {
            return node.getKind() == kind;
        };
    }

    /**
     * Gets if the provided value is a Node.
     */
    static isNode(value: unknown): value is compiler.Node {
        return value != null && (value as any).compilerNode != null
    }

    /**
     * Gets if the provided node is a comment node.
     */
    static isCommentNode(node: compiler.Node): node is compiler.CommentStatement | compiler.CommentClassElement | compiler.CommentTypeElement | compiler.CommentObjectLiteralElement | compiler.CommentEnumMember {
        const kind = node.getKind();
        return kind === SyntaxKind.SingleLineCommentTrivia || kind === SyntaxKind.MultiLineCommentTrivia;
    }

    /**
     * Gets if the provided node is a CommentStatement.
     */
    static isCommentStatement(node: compiler.Node): node is compiler.CommentStatement {
        return (node.compilerNode as compiler.CompilerCommentStatement)._commentKind === compiler.CommentNodeKind.Statement;
    }

    /**
     * Gets if the provided node is a CommentClassElement.
     */
    static isCommentClassElement(node: compiler.Node): node is compiler.CommentClassElement {
        return (node.compilerNode as compiler.CompilerCommentClassElement)._commentKind === compiler.CommentNodeKind.ClassElement;
    }

    /**
     * Gets if the provided value is a CommentTypeElement.
     */
    static isCommentTypeElement(node: compiler.Node): node is compiler.CommentTypeElement {
        return (node.compilerNode as compiler.CompilerCommentTypeElement)._commentKind === compiler.CommentNodeKind.TypeElement;
    }

    /**
     * Gets if the provided node is a CommentObjectLiteralElement.
     */
    static isCommentObjectLiteralElement(node: compiler.Node): node is compiler.CommentObjectLiteralElement {
        return (node.compilerNode as compiler.CompilerCommentObjectLiteralElement)._commentKind === compiler.CommentNodeKind.ObjectLiteralElement;
    }

    /**
     * Gets if the provided node is a CommentEnumMember.
     */
    static isCommentEnumMember(node: compiler.Node): node is compiler.CommentEnumMember {
        return (node.compilerNode as compiler.CompilerCommentEnumMember)._commentKind == compiler.CommentNodeKind.EnumMember;
    }

    /**
     * Gets if the node is an AbstractableNode.
     * @param node - Node to check.
     */
    static isAbstractableNode<T extends compiler.Node>(node: T): node is compiler.AbstractableNode & compiler.AbstractableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AmbientableNode.
     * @param node - Node to check.
     */
    static isAmbientableNode<T extends compiler.Node>(node: T): node is compiler.AmbientableNode & compiler.AmbientableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AnyKeyword.
     */
    static isAnyKeyword = TypeGuards.is(SyntaxKind.AnyKeyword);

    /**
     * Gets if the node is an ArgumentedNode.
     * @param node - Node to check.
     */
    static isArgumentedNode<T extends compiler.Node>(node: T): node is compiler.ArgumentedNode & compiler.ArgumentedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ArrayBindingPattern.
     */
    static isArrayBindingPattern = TypeGuards.is(SyntaxKind.ArrayBindingPattern);
    /**
     * Gets if the node is an ArrayLiteralExpression.
     */
    static isArrayLiteralExpression = TypeGuards.is(SyntaxKind.ArrayLiteralExpression);

    /**
     * Gets if the node is an ArrayTypeNode.
     * @param node - Node to check.
     */
    static isArrayTypeNode(node: compiler.Node): node is compiler.ArrayTypeNode {
        return node.getKind() === SyntaxKind.ArrayType;
    }

    /**
     * Gets if the node is an ArrowFunction.
     */
    static isArrowFunction = TypeGuards.is(SyntaxKind.ArrowFunction);
    /**
     * Gets if the node is an AsExpression.
     */
    static isAsExpression = TypeGuards.is(SyntaxKind.AsExpression);

    /**
     * Gets if the node is an AsyncableNode.
     * @param node - Node to check.
     */
    static isAsyncableNode<T extends compiler.Node>(node: T): node is compiler.AsyncableNode & compiler.AsyncableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AwaitExpression.
     */
    static isAwaitExpression = TypeGuards.is(SyntaxKind.AwaitExpression);

    /**
     * Gets if the node is an AwaitableNode.
     * @param node - Node to check.
     */
    static isAwaitableNode<T extends compiler.Node>(node: T): node is compiler.AwaitableNode & compiler.AwaitableNodeExtensionType & T {
        return node.getKind() === SyntaxKind.ForOfStatement;
    }

    /**
     * Gets if the node is a BinaryExpression.
     */
    static isBinaryExpression = TypeGuards.is(SyntaxKind.BinaryExpression);
    /**
     * Gets if the node is a BindingElement.
     */
    static isBindingElement = TypeGuards.is(SyntaxKind.BindingElement);

    /**
     * Gets if the node is a BindingNamedNode.
     * @param node - Node to check.
     */
    static isBindingNamedNode<T extends compiler.Node>(node: T): node is compiler.BindingNamedNode & compiler.BindingNamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.Parameter:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Block.
     */
    static isBlock = TypeGuards.is(SyntaxKind.Block);

    /**
     * Gets if the node is a BodiedNode.
     * @param node - Node to check.
     */
    static isBodiedNode<T extends compiler.Node>(node: T): node is compiler.BodiedNode & compiler.BodiedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BodyableNode.
     * @param node - Node to check.
     */
    static isBodyableNode<T extends compiler.Node>(node: T): node is compiler.BodyableNode & compiler.BodyableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BooleanKeyword.
     */
    static isBooleanKeyword = TypeGuards.is(SyntaxKind.BooleanKeyword);

    /**
     * Gets if the node is a BooleanLiteral.
     * @param node - Node to check.
     */
    static isBooleanLiteral(node: compiler.Node): node is compiler.BooleanLiteral {
        switch (node.getKind()) {
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BreakStatement.
     */
    static isBreakStatement = TypeGuards.is(SyntaxKind.BreakStatement);
    /**
     * Gets if the node is a CallExpression.
     */
    static isCallExpression = TypeGuards.is(SyntaxKind.CallExpression);

    /**
     * Gets if the node is a CallSignatureDeclaration.
     * @param node - Node to check.
     */
    static isCallSignatureDeclaration(node: compiler.Node): node is compiler.CallSignatureDeclaration {
        return node.getKind() === SyntaxKind.CallSignature;
    }

    /**
     * Gets if the node is a CaseBlock.
     */
    static isCaseBlock = TypeGuards.is(SyntaxKind.CaseBlock);
    /**
     * Gets if the node is a CaseClause.
     */
    static isCaseClause = TypeGuards.is(SyntaxKind.CaseClause);
    /**
     * Gets if the node is a CatchClause.
     */
    static isCatchClause = TypeGuards.is(SyntaxKind.CatchClause);

    /**
     * Gets if the node is a ChildOrderableNode.
     * @param node - Node to check.
     */
    static isChildOrderableNode<T extends compiler.Node>(node: T): node is compiler.ChildOrderableNode & compiler.ChildOrderableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.ExportDeclaration:
            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleBlock:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.Block:
            case SyntaxKind.BreakStatement:
            case SyntaxKind.ContinueStatement:
            case SyntaxKind.DebuggerStatement:
            case SyntaxKind.DoStatement:
            case SyntaxKind.EmptyStatement:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.IfStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.NotEmittedStatement:
            case SyntaxKind.ReturnStatement:
            case SyntaxKind.SwitchStatement:
            case SyntaxKind.ThrowStatement:
            case SyntaxKind.TryStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.WhileStatement:
            case SyntaxKind.WithStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ClassDeclaration.
     */
    static isClassDeclaration = TypeGuards.is(SyntaxKind.ClassDeclaration);
    /**
     * Gets if the node is a ClassExpression.
     */
    static isClassExpression = TypeGuards.is(SyntaxKind.ClassExpression);

    /**
     * Gets if the node is a ClassLikeDeclarationBase.
     * @param node - Node to check.
     */
    static isClassLikeDeclarationBase<T extends compiler.Node>(node: T): node is compiler.ClassLikeDeclarationBase & compiler.ClassLikeDeclarationBaseExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a CommaListExpression.
     */
    static isCommaListExpression = TypeGuards.is(SyntaxKind.CommaListExpression);
    /**
     * Gets if the node is a ComputedPropertyName.
     */
    static isComputedPropertyName = TypeGuards.is(SyntaxKind.ComputedPropertyName);
    /**
     * Gets if the node is a ConditionalExpression.
     */
    static isConditionalExpression = TypeGuards.is(SyntaxKind.ConditionalExpression);

    /**
     * Gets if the node is a ConditionalTypeNode.
     * @param node - Node to check.
     */
    static isConditionalTypeNode(node: compiler.Node): node is compiler.ConditionalTypeNode {
        return node.getKind() === SyntaxKind.ConditionalType;
    }

    /**
     * Gets if the node is a ConstructSignatureDeclaration.
     * @param node - Node to check.
     */
    static isConstructSignatureDeclaration(node: compiler.Node): node is compiler.ConstructSignatureDeclaration {
        return node.getKind() === SyntaxKind.ConstructSignature;
    }

    /**
     * Gets if the node is a ConstructorDeclaration.
     * @param node - Node to check.
     */
    static isConstructorDeclaration(node: compiler.Node): node is compiler.ConstructorDeclaration {
        return node.getKind() === SyntaxKind.Constructor;
    }

    /**
     * Gets if the node is a ConstructorTypeNode.
     * @param node - Node to check.
     */
    static isConstructorTypeNode(node: compiler.Node): node is compiler.ConstructorTypeNode {
        return node.getKind() === SyntaxKind.ConstructorType;
    }

    /**
     * Gets if the node is a ContinueStatement.
     */
    static isContinueStatement = TypeGuards.is(SyntaxKind.ContinueStatement);
    /**
     * Gets if the node is a DebuggerStatement.
     */
    static isDebuggerStatement = TypeGuards.is(SyntaxKind.DebuggerStatement);

    /**
     * Gets if the node is a DecoratableNode.
     * @param node - Node to check.
     */
    static isDecoratableNode<T extends compiler.Node>(node: T): node is compiler.DecoratableNode & compiler.DecoratableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Decorator.
     */
    static isDecorator = TypeGuards.is(SyntaxKind.Decorator);
    /**
     * Gets if the node is a DefaultClause.
     */
    static isDefaultClause = TypeGuards.is(SyntaxKind.DefaultClause);
    /**
     * Gets if the node is a DeleteExpression.
     */
    static isDeleteExpression = TypeGuards.is(SyntaxKind.DeleteExpression);
    /**
     * Gets if the node is a DoStatement.
     */
    static isDoStatement = TypeGuards.is(SyntaxKind.DoStatement);
    /**
     * Gets if the node is an ElementAccessExpression.
     */
    static isElementAccessExpression = TypeGuards.is(SyntaxKind.ElementAccessExpression);
    /**
     * Gets if the node is an EmptyStatement.
     */
    static isEmptyStatement = TypeGuards.is(SyntaxKind.EmptyStatement);
    /**
     * Gets if the node is an EnumDeclaration.
     */
    static isEnumDeclaration = TypeGuards.is(SyntaxKind.EnumDeclaration);
    /**
     * Gets if the node is an EnumMember.
     */
    static isEnumMember = TypeGuards.is(SyntaxKind.EnumMember);

    /**
     * Gets if the node is an ExclamationTokenableNode.
     * @param node - Node to check.
     */
    static isExclamationTokenableNode<T extends compiler.Node>(node: T): node is compiler.ExclamationTokenableNode & compiler.ExclamationTokenableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExportAssignment.
     */
    static isExportAssignment = TypeGuards.is(SyntaxKind.ExportAssignment);
    /**
     * Gets if the node is an ExportDeclaration.
     */
    static isExportDeclaration = TypeGuards.is(SyntaxKind.ExportDeclaration);

    /**
     * Gets if the node is an ExportGetableNode.
     * @param node - Node to check.
     */
    static isExportGetableNode<T extends compiler.Node>(node: T): node is compiler.ExportGetableNode & compiler.ExportGetableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExportSpecifier.
     */
    static isExportSpecifier = TypeGuards.is(SyntaxKind.ExportSpecifier);

    /**
     * Gets if the node is an ExportableNode.
     * @param node - Node to check.
     */
    static isExportableNode<T extends compiler.Node>(node: T): node is compiler.ExportableNode & compiler.ExportableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an Expression.
     * @param node - Node to check.
     */
    static isExpression(node: compiler.Node): node is compiler.Expression {
        switch (node.getKind()) {
            case SyntaxKind.AnyKeyword:
            case SyntaxKind.BooleanKeyword:
            case SyntaxKind.NeverKeyword:
            case SyntaxKind.NumberKeyword:
            case SyntaxKind.ObjectKeyword:
            case SyntaxKind.StringKeyword:
            case SyntaxKind.SymbolKeyword:
            case SyntaxKind.UndefinedKeyword:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.AsExpression:
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.BinaryExpression:
            case SyntaxKind.CallExpression:
            case SyntaxKind.CommaListExpression:
            case SyntaxKind.ConditionalExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.OmittedExpression:
            case SyntaxKind.ParenthesizedExpression:
            case SyntaxKind.PartiallyEmittedExpression:
            case SyntaxKind.PostfixUnaryExpression:
            case SyntaxKind.PrefixUnaryExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SpreadElement:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidExpression:
            case SyntaxKind.YieldExpression:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxClosingFragment:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxExpression:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxOpeningFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExpressionStatement.
     */
    static isExpressionStatement = TypeGuards.is(SyntaxKind.ExpressionStatement);
    /**
     * Gets if the node is an ExpressionWithTypeArguments.
     */
    static isExpressionWithTypeArguments = TypeGuards.is(SyntaxKind.ExpressionWithTypeArguments);

    /**
     * Gets if the node is an ExpressionedNode.
     * @param node - Node to check.
     */
    static isExpressionedNode<T extends compiler.Node>(node: T): node is compiler.ExpressionedNode & compiler.ExpressionedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.AsExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.ParenthesizedExpression:
            case SyntaxKind.PartiallyEmittedExpression:
            case SyntaxKind.SpreadElement:
            case SyntaxKind.SpreadAssignment:
            case SyntaxKind.TemplateSpan:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExtendsClauseableNode.
     * @param node - Node to check.
     */
    static isExtendsClauseableNode<T extends compiler.Node>(node: T): node is compiler.ExtendsClauseableNode & compiler.ExtendsClauseableNodeExtensionType & T {
        return node.getKind() === SyntaxKind.InterfaceDeclaration;
    }

    /**
     * Gets if the node is an ExternalModuleReference.
     */
    static isExternalModuleReference = TypeGuards.is(SyntaxKind.ExternalModuleReference);
    /**
     * Gets if the node is a FalseKeyword.
     */
    static isFalseKeyword = TypeGuards.is(SyntaxKind.FalseKeyword);
    /**
     * Gets if the node is a ForInStatement.
     */
    static isForInStatement = TypeGuards.is(SyntaxKind.ForInStatement);
    /**
     * Gets if the node is a ForOfStatement.
     */
    static isForOfStatement = TypeGuards.is(SyntaxKind.ForOfStatement);
    /**
     * Gets if the node is a ForStatement.
     */
    static isForStatement = TypeGuards.is(SyntaxKind.ForStatement);
    /**
     * Gets if the node is a FunctionDeclaration.
     */
    static isFunctionDeclaration = TypeGuards.is(SyntaxKind.FunctionDeclaration);
    /**
     * Gets if the node is a FunctionExpression.
     */
    static isFunctionExpression = TypeGuards.is(SyntaxKind.FunctionExpression);

    /**
     * Gets if the node is a FunctionLikeDeclaration.
     * @param node - Node to check.
     */
    static isFunctionLikeDeclaration<T extends compiler.Node>(node: T): node is compiler.FunctionLikeDeclaration & compiler.FunctionLikeDeclarationExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a FunctionTypeNode.
     * @param node - Node to check.
     */
    static isFunctionTypeNode(node: compiler.Node): node is compiler.FunctionTypeNode {
        return node.getKind() === SyntaxKind.FunctionType;
    }

    /**
     * Gets if the node is a GeneratorableNode.
     * @param node - Node to check.
     */
    static isGeneratorableNode<T extends compiler.Node>(node: T): node is compiler.GeneratorableNode & compiler.GeneratorableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.YieldExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a GetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isGetAccessorDeclaration(node: compiler.Node): node is compiler.GetAccessorDeclaration {
        return node.getKind() === SyntaxKind.GetAccessor;
    }

    /**
     * Gets if the node is a HeritageClause.
     */
    static isHeritageClause = TypeGuards.is(SyntaxKind.HeritageClause);

    /**
     * Gets if the node is a HeritageClauseableNode.
     * @param node - Node to check.
     */
    static isHeritageClauseableNode<T extends compiler.Node>(node: T): node is compiler.HeritageClauseableNode & compiler.HeritageClauseableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Identifier.
     */
    static isIdentifier = TypeGuards.is(SyntaxKind.Identifier);
    /**
     * Gets if the node is a IfStatement.
     */
    static isIfStatement = TypeGuards.is(SyntaxKind.IfStatement);

    /**
     * Gets if the node is a ImplementsClauseableNode.
     * @param node - Node to check.
     */
    static isImplementsClauseableNode<T extends compiler.Node>(node: T): node is compiler.ImplementsClauseableNode & compiler.ImplementsClauseableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ImportClause.
     */
    static isImportClause = TypeGuards.is(SyntaxKind.ImportClause);
    /**
     * Gets if the node is a ImportDeclaration.
     */
    static isImportDeclaration = TypeGuards.is(SyntaxKind.ImportDeclaration);
    /**
     * Gets if the node is a ImportEqualsDeclaration.
     */
    static isImportEqualsDeclaration = TypeGuards.is(SyntaxKind.ImportEqualsDeclaration);

    /**
     * Gets if the node is a ImportExpression.
     * @param node - Node to check.
     */
    static isImportExpression(node: compiler.Node): node is compiler.ImportExpression {
        return node.getKind() === SyntaxKind.ImportKeyword;
    }

    /**
     * Gets if the node is a ImportSpecifier.
     */
    static isImportSpecifier = TypeGuards.is(SyntaxKind.ImportSpecifier);

    /**
     * Gets if the node is a ImportTypeNode.
     * @param node - Node to check.
     */
    static isImportTypeNode(node: compiler.Node): node is compiler.ImportTypeNode {
        return node.getKind() === SyntaxKind.ImportType;
    }

    /**
     * Gets if the node is a IndexSignatureDeclaration.
     * @param node - Node to check.
     */
    static isIndexSignatureDeclaration(node: compiler.Node): node is compiler.IndexSignatureDeclaration {
        return node.getKind() === SyntaxKind.IndexSignature;
    }

    /**
     * Gets if the node is a IndexedAccessTypeNode.
     * @param node - Node to check.
     */
    static isIndexedAccessTypeNode(node: compiler.Node): node is compiler.IndexedAccessTypeNode {
        return node.getKind() === SyntaxKind.IndexedAccessType;
    }

    /**
     * Gets if the node is a InferKeyword.
     */
    static isInferKeyword = TypeGuards.is(SyntaxKind.InferKeyword);

    /**
     * Gets if the node is a InferTypeNode.
     * @param node - Node to check.
     */
    static isInferTypeNode(node: compiler.Node): node is compiler.InferTypeNode {
        return node.getKind() === SyntaxKind.InferType;
    }

    /**
     * Gets if the node is a InitializerExpressionGetableNode.
     * @param node - Node to check.
     */
    static isInitializerExpressionGetableNode<T extends compiler.Node>(node: T): node is compiler.InitializerExpressionGetableNode & compiler.InitializerExpressionGetableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a InitializerExpressionableNode.
     * @param node - Node to check.
     */
    static isInitializerExpressionableNode<T extends compiler.Node>(node: T): node is compiler.InitializerExpressionableNode & compiler.InitializerExpressionableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a InterfaceDeclaration.
     */
    static isInterfaceDeclaration = TypeGuards.is(SyntaxKind.InterfaceDeclaration);

    /**
     * Gets if the node is a IntersectionTypeNode.
     * @param node - Node to check.
     */
    static isIntersectionTypeNode(node: compiler.Node): node is compiler.IntersectionTypeNode {
        return node.getKind() === SyntaxKind.IntersectionType;
    }

    /**
     * Gets if the node is a IterationStatement.
     * @param node - Node to check.
     */
    static isIterationStatement(node: compiler.Node): node is compiler.IterationStatement {
        switch (node.getKind()) {
            case SyntaxKind.DoStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.WhileStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDoc.
     * @param node - Node to check.
     */
    static isJSDoc(node: compiler.Node): node is compiler.JSDoc {
        return node.getKind() === SyntaxKind.JSDocComment;
    }

    /**
     * Gets if the node is a JSDocAugmentsTag.
     */
    static isJSDocAugmentsTag = TypeGuards.is(SyntaxKind.JSDocAugmentsTag);
    /**
     * Gets if the node is a JSDocClassTag.
     */
    static isJSDocClassTag = TypeGuards.is(SyntaxKind.JSDocClassTag);
    /**
     * Gets if the node is a JSDocFunctionType.
     */
    static isJSDocFunctionType = TypeGuards.is(SyntaxKind.JSDocFunctionType);
    /**
     * Gets if the node is a JSDocParameterTag.
     */
    static isJSDocParameterTag = TypeGuards.is(SyntaxKind.JSDocParameterTag);

    /**
     * Gets if the node is a JSDocPropertyLikeTag.
     * @param node - Node to check.
     */
    static isJSDocPropertyLikeTag<T extends compiler.Node>(node: T): node is compiler.JSDocPropertyLikeTag & compiler.JSDocPropertyLikeTagExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JSDocParameterTag:
            case SyntaxKind.JSDocPropertyTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocPropertyTag.
     */
    static isJSDocPropertyTag = TypeGuards.is(SyntaxKind.JSDocPropertyTag);
    /**
     * Gets if the node is a JSDocReturnTag.
     */
    static isJSDocReturnTag = TypeGuards.is(SyntaxKind.JSDocReturnTag);
    /**
     * Gets if the node is a JSDocSignature.
     */
    static isJSDocSignature = TypeGuards.is(SyntaxKind.JSDocSignature);

    /**
     * Gets if the node is a JSDocTag.
     * @param node - Node to check.
     */
    static isJSDocTag(node: compiler.Node): node is compiler.JSDocTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocAugmentsTag:
            case SyntaxKind.JSDocClassTag:
            case SyntaxKind.JSDocParameterTag:
            case SyntaxKind.JSDocPropertyTag:
            case SyntaxKind.JSDocReturnTag:
            case SyntaxKind.JSDocTypedefTag:
            case SyntaxKind.JSDocTypeTag:
            case SyntaxKind.JSDocTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocType.
     * @param node - Node to check.
     */
    static isJSDocType(node: compiler.Node): node is compiler.JSDocType {
        switch (node.getKind()) {
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.JSDocSignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocTypeExpression.
     */
    static isJSDocTypeExpression = TypeGuards.is(SyntaxKind.JSDocTypeExpression);
    /**
     * Gets if the node is a JSDocTypeTag.
     */
    static isJSDocTypeTag = TypeGuards.is(SyntaxKind.JSDocTypeTag);
    /**
     * Gets if the node is a JSDocTypedefTag.
     */
    static isJSDocTypedefTag = TypeGuards.is(SyntaxKind.JSDocTypedefTag);

    /**
     * Gets if the node is a JSDocUnknownTag.
     * @param node - Node to check.
     */
    static isJSDocUnknownTag(node: compiler.Node): node is compiler.JSDocUnknownTag {
        return node.getKind() === SyntaxKind.JSDocTag;
    }

    /**
     * Gets if the node is a JSDocableNode.
     * @param node - Node to check.
     */
    static isJSDocableNode<T extends compiler.Node>(node: T): node is compiler.JSDocableNode & compiler.JSDocableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxAttribute.
     */
    static isJsxAttribute = TypeGuards.is(SyntaxKind.JsxAttribute);

    /**
     * Gets if the node is a JsxAttributedNode.
     * @param node - Node to check.
     */
    static isJsxAttributedNode<T extends compiler.Node>(node: T): node is compiler.JsxAttributedNode & compiler.JsxAttributedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxClosingElement.
     */
    static isJsxClosingElement = TypeGuards.is(SyntaxKind.JsxClosingElement);
    /**
     * Gets if the node is a JsxClosingFragment.
     */
    static isJsxClosingFragment = TypeGuards.is(SyntaxKind.JsxClosingFragment);
    /**
     * Gets if the node is a JsxElement.
     */
    static isJsxElement = TypeGuards.is(SyntaxKind.JsxElement);
    /**
     * Gets if the node is a JsxExpression.
     */
    static isJsxExpression = TypeGuards.is(SyntaxKind.JsxExpression);
    /**
     * Gets if the node is a JsxFragment.
     */
    static isJsxFragment = TypeGuards.is(SyntaxKind.JsxFragment);
    /**
     * Gets if the node is a JsxOpeningElement.
     */
    static isJsxOpeningElement = TypeGuards.is(SyntaxKind.JsxOpeningElement);
    /**
     * Gets if the node is a JsxOpeningFragment.
     */
    static isJsxOpeningFragment = TypeGuards.is(SyntaxKind.JsxOpeningFragment);
    /**
     * Gets if the node is a JsxSelfClosingElement.
     */
    static isJsxSelfClosingElement = TypeGuards.is(SyntaxKind.JsxSelfClosingElement);
    /**
     * Gets if the node is a JsxSpreadAttribute.
     */
    static isJsxSpreadAttribute = TypeGuards.is(SyntaxKind.JsxSpreadAttribute);

    /**
     * Gets if the node is a JsxTagNamedNode.
     * @param node - Node to check.
     */
    static isJsxTagNamedNode<T extends compiler.Node>(node: T): node is compiler.JsxTagNamedNode & compiler.JsxTagNamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JsxClosingElement:
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxText.
     */
    static isJsxText = TypeGuards.is(SyntaxKind.JsxText);
    /**
     * Gets if the node is a LabeledStatement.
     */
    static isLabeledStatement = TypeGuards.is(SyntaxKind.LabeledStatement);

    /**
     * Gets if the node is a LeftHandSideExpression.
     * @param node - Node to check.
     */
    static isLeftHandSideExpression(node: compiler.Node): node is compiler.LeftHandSideExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LeftHandSideExpressionedNode.
     * @param node - Node to check.
     */
    static isLeftHandSideExpressionedNode<T extends compiler.Node>(node: T): node is compiler.LeftHandSideExpressionedNode & compiler.LeftHandSideExpressionedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.NewExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ExpressionWithTypeArguments:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralExpression.
     * @param node - Node to check.
     */
    static isLiteralExpression(node: compiler.Node): node is compiler.LiteralExpression {
        switch (node.getKind()) {
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralLikeNode.
     * @param node - Node to check.
     */
    static isLiteralLikeNode<T extends compiler.Node>(node: T): node is compiler.LiteralLikeNode & compiler.LiteralLikeNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JsxText:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TemplateHead:
            case SyntaxKind.TemplateMiddle:
            case SyntaxKind.TemplateTail:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralTypeNode.
     * @param node - Node to check.
     */
    static isLiteralTypeNode(node: compiler.Node): node is compiler.LiteralTypeNode {
        return node.getKind() === SyntaxKind.LiteralType;
    }

    /**
     * Gets if the node is a MemberExpression.
     * @param node - Node to check.
     */
    static isMemberExpression(node: compiler.Node): node is compiler.MemberExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a MetaProperty.
     */
    static isMetaProperty = TypeGuards.is(SyntaxKind.MetaProperty);
    /**
     * Gets if the node is a MethodDeclaration.
     */
    static isMethodDeclaration = TypeGuards.is(SyntaxKind.MethodDeclaration);
    /**
     * Gets if the node is a MethodSignature.
     */
    static isMethodSignature = TypeGuards.is(SyntaxKind.MethodSignature);

    /**
     * Gets if the node is a ModifierableNode.
     * @param node - Node to check.
     */
    static isModifierableNode<T extends compiler.Node>(node: T): node is compiler.ModifierableNode & compiler.ModifierableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.VariableDeclarationList:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ModuleBlock.
     */
    static isModuleBlock = TypeGuards.is(SyntaxKind.ModuleBlock);

    /**
     * Gets if the node is a ModuledNode.
     * @param node - Node to check.
     */
    static isModuledNode<T extends compiler.Node>(node: T): node is compiler.ModuledNode & compiler.ModuledNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NameableNode.
     * @param node - Node to check.
     */
    static isNameableNode<T extends compiler.Node>(node: T): node is compiler.NameableNode & compiler.NameableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamedExports.
     */
    static isNamedExports = TypeGuards.is(SyntaxKind.NamedExports);
    /**
     * Gets if the node is a NamedImports.
     */
    static isNamedImports = TypeGuards.is(SyntaxKind.NamedImports);

    /**
     * Gets if the node is a NamedNode.
     * @param node - Node to check.
     */
    static isNamedNode<T extends compiler.Node>(node: T): node is compiler.NamedNode & compiler.NamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamespaceChildableNode.
     * @param node - Node to check.
     */
    static isNamespaceChildableNode<T extends compiler.Node>(node: T): node is compiler.NamespaceChildableNode & compiler.NamespaceChildableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamespaceDeclaration.
     * @param node - Node to check.
     */
    static isNamespaceDeclaration(node: compiler.Node): node is compiler.NamespaceDeclaration {
        return node.getKind() === SyntaxKind.ModuleDeclaration;
    }

    /**
     * Gets if the node is a NamespaceImport.
     */
    static isNamespaceImport = TypeGuards.is(SyntaxKind.NamespaceImport);
    /**
     * Gets if the node is a NeverKeyword.
     */
    static isNeverKeyword = TypeGuards.is(SyntaxKind.NeverKeyword);
    /**
     * Gets if the node is a NewExpression.
     */
    static isNewExpression = TypeGuards.is(SyntaxKind.NewExpression);
    /**
     * Gets if the node is a NoSubstitutionTemplateLiteral.
     */
    static isNoSubstitutionTemplateLiteral = TypeGuards.is(SyntaxKind.NoSubstitutionTemplateLiteral);
    /**
     * Gets if the node is a NonNullExpression.
     */
    static isNonNullExpression = TypeGuards.is(SyntaxKind.NonNullExpression);
    /**
     * Gets if the node is a NotEmittedStatement.
     */
    static isNotEmittedStatement = TypeGuards.is(SyntaxKind.NotEmittedStatement);

    /**
     * Gets if the node is a NullLiteral.
     * @param node - Node to check.
     */
    static isNullLiteral(node: compiler.Node): node is compiler.NullLiteral {
        return node.getKind() === SyntaxKind.NullKeyword;
    }

    /**
     * Gets if the node is a NumberKeyword.
     */
    static isNumberKeyword = TypeGuards.is(SyntaxKind.NumberKeyword);
    /**
     * Gets if the node is a NumericLiteral.
     */
    static isNumericLiteral = TypeGuards.is(SyntaxKind.NumericLiteral);
    /**
     * Gets if the node is a ObjectBindingPattern.
     */
    static isObjectBindingPattern = TypeGuards.is(SyntaxKind.ObjectBindingPattern);
    /**
     * Gets if the node is a ObjectKeyword.
     */
    static isObjectKeyword = TypeGuards.is(SyntaxKind.ObjectKeyword);
    /**
     * Gets if the node is a ObjectLiteralExpression.
     */
    static isObjectLiteralExpression = TypeGuards.is(SyntaxKind.ObjectLiteralExpression);
    /**
     * Gets if the node is a OmittedExpression.
     */
    static isOmittedExpression = TypeGuards.is(SyntaxKind.OmittedExpression);

    /**
     * Gets if the node is a OverloadableNode.
     * @param node - Node to check.
     */
    static isOverloadableNode<T extends compiler.Node>(node: T): node is compiler.OverloadableNode & compiler.OverloadableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ParameterDeclaration.
     * @param node - Node to check.
     */
    static isParameterDeclaration(node: compiler.Node): node is compiler.ParameterDeclaration {
        return node.getKind() === SyntaxKind.Parameter;
    }

    /**
     * Gets if the node is a ParameteredNode.
     * @param node - Node to check.
     */
    static isParameteredNode<T extends compiler.Node>(node: T): node is compiler.ParameteredNode & compiler.ParameteredNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ParenthesizedExpression.
     */
    static isParenthesizedExpression = TypeGuards.is(SyntaxKind.ParenthesizedExpression);

    /**
     * Gets if the node is a ParenthesizedTypeNode.
     * @param node - Node to check.
     */
    static isParenthesizedTypeNode(node: compiler.Node): node is compiler.ParenthesizedTypeNode {
        return node.getKind() === SyntaxKind.ParenthesizedType;
    }

    /**
     * Gets if the node is a PartiallyEmittedExpression.
     */
    static isPartiallyEmittedExpression = TypeGuards.is(SyntaxKind.PartiallyEmittedExpression);
    /**
     * Gets if the node is a PostfixUnaryExpression.
     */
    static isPostfixUnaryExpression = TypeGuards.is(SyntaxKind.PostfixUnaryExpression);
    /**
     * Gets if the node is a PrefixUnaryExpression.
     */
    static isPrefixUnaryExpression = TypeGuards.is(SyntaxKind.PrefixUnaryExpression);

    /**
     * Gets if the node is a PrimaryExpression.
     * @param node - Node to check.
     */
    static isPrimaryExpression(node: compiler.Node): node is compiler.PrimaryExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PropertyAccessExpression.
     */
    static isPropertyAccessExpression = TypeGuards.is(SyntaxKind.PropertyAccessExpression);
    /**
     * Gets if the node is a PropertyAssignment.
     */
    static isPropertyAssignment = TypeGuards.is(SyntaxKind.PropertyAssignment);
    /**
     * Gets if the node is a PropertyDeclaration.
     */
    static isPropertyDeclaration = TypeGuards.is(SyntaxKind.PropertyDeclaration);

    /**
     * Gets if the node is a PropertyNamedNode.
     * @param node - Node to check.
     */
    static isPropertyNamedNode<T extends compiler.Node>(node: T): node is compiler.PropertyNamedNode & compiler.PropertyNamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumMember:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.PropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PropertySignature.
     */
    static isPropertySignature = TypeGuards.is(SyntaxKind.PropertySignature);
    /**
     * Gets if the node is a QualifiedName.
     */
    static isQualifiedName = TypeGuards.is(SyntaxKind.QualifiedName);

    /**
     * Gets if the node is a QuestionTokenableNode.
     * @param node - Node to check.
     */
    static isQuestionTokenableNode<T extends compiler.Node>(node: T): node is compiler.QuestionTokenableNode & compiler.QuestionTokenableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReadonlyableNode.
     * @param node - Node to check.
     */
    static isReadonlyableNode<T extends compiler.Node>(node: T): node is compiler.ReadonlyableNode & compiler.ReadonlyableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReferenceFindableNode.
     * @param node - Node to check.
     */
    static isReferenceFindableNode<T extends compiler.Node>(node: T): node is compiler.ReferenceFindableNode & compiler.ReferenceFindableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Identifier:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a RegularExpressionLiteral.
     */
    static isRegularExpressionLiteral = TypeGuards.is(SyntaxKind.RegularExpressionLiteral);

    /**
     * Gets if the node is a RenameableNode.
     * @param node - Node to check.
     */
    static isRenameableNode<T extends compiler.Node>(node: T): node is compiler.RenameableNode & compiler.RenameableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Identifier:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.NamespaceImport:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReturnStatement.
     */
    static isReturnStatement = TypeGuards.is(SyntaxKind.ReturnStatement);

    /**
     * Gets if the node is a ReturnTypedNode.
     * @param node - Node to check.
     */
    static isReturnTypedNode<T extends compiler.Node>(node: T): node is compiler.ReturnTypedNode & compiler.ReturnTypedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ScopeableNode.
     * @param node - Node to check.
     */
    static isScopeableNode<T extends compiler.Node>(node: T): node is compiler.ScopeableNode & compiler.ScopeableNodeExtensionType & T {
        return node.getKind() === SyntaxKind.Parameter;
    }

    /**
     * Gets if the node is a ScopedNode.
     * @param node - Node to check.
     */
    static isScopedNode<T extends compiler.Node>(node: T): node is compiler.ScopedNode & compiler.ScopedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SemicolonToken.
     */
    static isSemicolonToken = TypeGuards.is(SyntaxKind.SemicolonToken);

    /**
     * Gets if the node is a SetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isSetAccessorDeclaration(node: compiler.Node): node is compiler.SetAccessorDeclaration {
        return node.getKind() === SyntaxKind.SetAccessor;
    }

    /**
     * Gets if the node is a ShorthandPropertyAssignment.
     */
    static isShorthandPropertyAssignment = TypeGuards.is(SyntaxKind.ShorthandPropertyAssignment);

    /**
     * Gets if the node is a SignaturedDeclaration.
     * @param node - Node to check.
     */
    static isSignaturedDeclaration<T extends compiler.Node>(node: T): node is compiler.SignaturedDeclaration & compiler.SignaturedDeclarationExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SourceFile.
     */
    static isSourceFile = TypeGuards.is(SyntaxKind.SourceFile);
    /**
     * Gets if the node is a SpreadAssignment.
     */
    static isSpreadAssignment = TypeGuards.is(SyntaxKind.SpreadAssignment);
    /**
     * Gets if the node is a SpreadElement.
     */
    static isSpreadElement = TypeGuards.is(SyntaxKind.SpreadElement);

    /**
     * Gets if the node is a Statement.
     * @param node - Node to check.
     */
    static isStatement(node: compiler.Node): node is compiler.Statement {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.ExportDeclaration:
            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleBlock:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.Block:
            case SyntaxKind.BreakStatement:
            case SyntaxKind.ContinueStatement:
            case SyntaxKind.DebuggerStatement:
            case SyntaxKind.DoStatement:
            case SyntaxKind.EmptyStatement:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.IfStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.NotEmittedStatement:
            case SyntaxKind.ReturnStatement:
            case SyntaxKind.SwitchStatement:
            case SyntaxKind.ThrowStatement:
            case SyntaxKind.TryStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.WhileStatement:
            case SyntaxKind.WithStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StatementedNode.
     * @param node - Node to check.
     */
    static isStatementedNode<T extends compiler.Node>(node: T): node is compiler.StatementedNode & compiler.StatementedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ModuleBlock:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
            case SyntaxKind.Block:
            case SyntaxKind.CaseClause:
            case SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StaticableNode.
     * @param node - Node to check.
     */
    static isStaticableNode<T extends compiler.Node>(node: T): node is compiler.StaticableNode & compiler.StaticableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StringKeyword.
     */
    static isStringKeyword = TypeGuards.is(SyntaxKind.StringKeyword);
    /**
     * Gets if the node is a StringLiteral.
     */
    static isStringLiteral = TypeGuards.is(SyntaxKind.StringLiteral);

    /**
     * Gets if the node is a SuperExpression.
     * @param node - Node to check.
     */
    static isSuperExpression(node: compiler.Node): node is compiler.SuperExpression {
        return node.getKind() === SyntaxKind.SuperKeyword;
    }

    /**
     * Gets if the node is a SwitchStatement.
     */
    static isSwitchStatement = TypeGuards.is(SyntaxKind.SwitchStatement);
    /**
     * Gets if the node is a SymbolKeyword.
     */
    static isSymbolKeyword = TypeGuards.is(SyntaxKind.SymbolKeyword);
    /**
     * Gets if the node is a SyntaxList.
     */
    static isSyntaxList = TypeGuards.is(SyntaxKind.SyntaxList);
    /**
     * Gets if the node is a TaggedTemplateExpression.
     */
    static isTaggedTemplateExpression = TypeGuards.is(SyntaxKind.TaggedTemplateExpression);
    /**
     * Gets if the node is a TemplateExpression.
     */
    static isTemplateExpression = TypeGuards.is(SyntaxKind.TemplateExpression);
    /**
     * Gets if the node is a TemplateHead.
     */
    static isTemplateHead = TypeGuards.is(SyntaxKind.TemplateHead);
    /**
     * Gets if the node is a TemplateMiddle.
     */
    static isTemplateMiddle = TypeGuards.is(SyntaxKind.TemplateMiddle);
    /**
     * Gets if the node is a TemplateSpan.
     */
    static isTemplateSpan = TypeGuards.is(SyntaxKind.TemplateSpan);
    /**
     * Gets if the node is a TemplateTail.
     */
    static isTemplateTail = TypeGuards.is(SyntaxKind.TemplateTail);

    /**
     * Gets if the node is a TextInsertableNode.
     * @param node - Node to check.
     */
    static isTextInsertableNode<T extends compiler.Node>(node: T): node is compiler.TextInsertableNode & compiler.TextInsertableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
            case SyntaxKind.Block:
            case SyntaxKind.CaseBlock:
            case SyntaxKind.CaseClause:
            case SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ThisExpression.
     * @param node - Node to check.
     */
    static isThisExpression(node: compiler.Node): node is compiler.ThisExpression {
        return node.getKind() === SyntaxKind.ThisKeyword;
    }

    /**
     * Gets if the node is a ThisTypeNode.
     * @param node - Node to check.
     */
    static isThisTypeNode(node: compiler.Node): node is compiler.ThisTypeNode {
        return node.getKind() === SyntaxKind.ThisType;
    }

    /**
     * Gets if the node is a ThrowStatement.
     */
    static isThrowStatement = TypeGuards.is(SyntaxKind.ThrowStatement);
    /**
     * Gets if the node is a TrueKeyword.
     */
    static isTrueKeyword = TypeGuards.is(SyntaxKind.TrueKeyword);
    /**
     * Gets if the node is a TryStatement.
     */
    static isTryStatement = TypeGuards.is(SyntaxKind.TryStatement);

    /**
     * Gets if the node is a TupleTypeNode.
     * @param node - Node to check.
     */
    static isTupleTypeNode(node: compiler.Node): node is compiler.TupleTypeNode {
        return node.getKind() === SyntaxKind.TupleType;
    }

    /**
     * Gets if the node is a TypeAliasDeclaration.
     */
    static isTypeAliasDeclaration = TypeGuards.is(SyntaxKind.TypeAliasDeclaration);

    /**
     * Gets if the node is a TypeArgumentedNode.
     * @param node - Node to check.
     */
    static isTypeArgumentedNode<T extends compiler.Node>(node: T): node is compiler.TypeArgumentedNode & compiler.TypeArgumentedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:
            case SyntaxKind.ImportType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeAssertion.
     * @param node - Node to check.
     */
    static isTypeAssertion(node: compiler.Node): node is compiler.TypeAssertion {
        return node.getKind() === SyntaxKind.TypeAssertionExpression;
    }

    /**
     * Gets if the node is a TypeElement.
     * @param node - Node to check.
     */
    static isTypeElement(node: compiler.Node): node is compiler.TypeElement {
        switch (node.getKind()) {
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeElementMemberedNode.
     * @param node - Node to check.
     */
    static isTypeElementMemberedNode<T extends compiler.Node>(node: T): node is compiler.TypeElementMemberedNode & compiler.TypeElementMemberedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.TypeLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeLiteralNode.
     * @param node - Node to check.
     */
    static isTypeLiteralNode(node: compiler.Node): node is compiler.TypeLiteralNode {
        return node.getKind() === SyntaxKind.TypeLiteral;
    }

    /**
     * Gets if the node is a TypeNode.
     * @param node - Node to check.
     */
    static isTypeNode(node: compiler.Node): node is compiler.TypeNode {
        switch (node.getKind()) {
            case SyntaxKind.TypePredicate:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.JSDocSignature:
            case SyntaxKind.JSDocTypeExpression:
            case SyntaxKind.ArrayType:
            case SyntaxKind.ConditionalType:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.ExpressionWithTypeArguments:
            case SyntaxKind.FunctionType:
            case SyntaxKind.ImportType:
            case SyntaxKind.IndexedAccessType:
            case SyntaxKind.InferType:
            case SyntaxKind.IntersectionType:
            case SyntaxKind.LiteralType:
            case SyntaxKind.ParenthesizedType:
            case SyntaxKind.ThisType:
            case SyntaxKind.TupleType:
            case SyntaxKind.TypeLiteral:
            case SyntaxKind.TypeReference:
            case SyntaxKind.UnionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeOfExpression.
     */
    static isTypeOfExpression = TypeGuards.is(SyntaxKind.TypeOfExpression);

    /**
     * Gets if the node is a TypeParameterDeclaration.
     * @param node - Node to check.
     */
    static isTypeParameterDeclaration(node: compiler.Node): node is compiler.TypeParameterDeclaration {
        return node.getKind() === SyntaxKind.TypeParameter;
    }

    /**
     * Gets if the node is a TypeParameteredNode.
     * @param node - Node to check.
     */
    static isTypeParameteredNode<T extends compiler.Node>(node: T): node is compiler.TypeParameteredNode & compiler.TypeParameteredNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.FunctionType:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeReferenceNode.
     * @param node - Node to check.
     */
    static isTypeReferenceNode(node: compiler.Node): node is compiler.TypeReferenceNode {
        return node.getKind() === SyntaxKind.TypeReference;
    }

    /**
     * Gets if the node is a TypedNode.
     * @param node - Node to check.
     */
    static isTypedNode<T extends compiler.Node>(node: T): node is compiler.TypedNode & compiler.TypedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.AsExpression:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UnaryExpression.
     * @param node - Node to check.
     */
    static isUnaryExpression(node: compiler.Node): node is compiler.UnaryExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.CallExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PostfixUnaryExpression:
            case SyntaxKind.PrefixUnaryExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidExpression:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UnaryExpressionedNode.
     * @param node - Node to check.
     */
    static isUnaryExpressionedNode<T extends compiler.Node>(node: T): node is compiler.UnaryExpressionedNode & compiler.UnaryExpressionedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UndefinedKeyword.
     */
    static isUndefinedKeyword = TypeGuards.is(SyntaxKind.UndefinedKeyword);

    /**
     * Gets if the node is a UnionTypeNode.
     * @param node - Node to check.
     */
    static isUnionTypeNode(node: compiler.Node): node is compiler.UnionTypeNode {
        return node.getKind() === SyntaxKind.UnionType;
    }

    /**
     * Gets if the node is a UnwrappableNode.
     * @param node - Node to check.
     */
    static isUnwrappableNode<T extends compiler.Node>(node: T): node is compiler.UnwrappableNode & compiler.UnwrappableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UpdateExpression.
     * @param node - Node to check.
     */
    static isUpdateExpression(node: compiler.Node): node is compiler.UpdateExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a VariableDeclaration.
     */
    static isVariableDeclaration = TypeGuards.is(SyntaxKind.VariableDeclaration);
    /**
     * Gets if the node is a VariableDeclarationList.
     */
    static isVariableDeclarationList = TypeGuards.is(SyntaxKind.VariableDeclarationList);
    /**
     * Gets if the node is a VariableStatement.
     */
    static isVariableStatement = TypeGuards.is(SyntaxKind.VariableStatement);
    /**
     * Gets if the node is a VoidExpression.
     */
    static isVoidExpression = TypeGuards.is(SyntaxKind.VoidExpression);
    /**
     * Gets if the node is a WhileStatement.
     */
    static isWhileStatement = TypeGuards.is(SyntaxKind.WhileStatement);
    /**
     * Gets if the node is a WithStatement.
     */
    static isWithStatement = TypeGuards.is(SyntaxKind.WithStatement);
    /**
     * Gets if the node is a YieldExpression.
     */
    static isYieldExpression = TypeGuards.is(SyntaxKind.YieldExpression);

    /**
     * @internal
     */
    static _hasStructure(node: compiler.Node): node is compiler.Node & { getStructure(): Structure; } {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Decorator:
            case SyntaxKind.JSDocComment:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.JsxSpreadAttribute:
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.ExportDeclaration:
            case SyntaxKind.ExportSpecifier:
            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ImportSpecifier:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
            case SyntaxKind.SpreadAssignment:
                return true;
            default:
                return false;
        }
    }
}
