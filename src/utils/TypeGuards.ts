// -----------------------
// WARNING - DO NOT modify the "is" methods of the TypeGuards class directly. It is code generated by createTypeGuardsUtility.ts
//
// Note: This file is excluded from code coverage reports because it's automatically maintained (low risk).
// -----------------------

/* tslint:disable */
import * as compiler from "../compiler";
import { SyntaxKind } from "../typescript";
import { Structure } from "../structures";

/**
 * Type guards for checking the type of a node.
 */
export class TypeGuards {
    private constructor() {
    }

    /**
     * Gets if the node has an expression.
     * @param node - Node to check.
     */
    static hasExpression<T extends compiler.Node>(node: T): node is T & { getExpression(): compiler.Expression; } {
        // this method is manually maintained
        if ((node as any).getExpression == null)
            return false;
        return (node as any).getExpression() != null;
    }

    /**
     * Gets if the node has a name.
     * @param node - Node to check.
     */
    static hasName<T extends compiler.Node>(node: T): node is T & { getName(): string; getNameNode(): compiler.Node; } {
        // this method is manually maintained
        if ((node as any).getName == null)
            return false;
        return typeof (node as any).getName() === "string";
    }

    /**
     * Gets if the node has a body.
     * @param node - Node to check.
     */
    static hasBody<T extends compiler.Node>(node: T): node is T & { getBody(): compiler.Node; } {
        // this method is manually maintained
        if ((node as any).getBody == null)
            return false;
        return (node as any).getBody() != null;
    }

    /**
     * Gets if the provided value is a Node.
     */
    static isNode(value: unknown): value is compiler.Node {
        return value != null && (value as any).compilerNode != null
    }

    /**
     * Gets if the provided node is a comment node.
     */
    static isCommentNode(node: compiler.Node): node is CommentStatement | CommentClassElement | CommentTypeElement | CommentObjectLiteralElement | CommentEnumMember {
        return node.getKind() === SyntaxKind.SingleLineCommentTrivia || node.getKind() === SyntaxKind.MultiLineCommentTrivia;
    }

    /**
     * Gets if the provided node is a CommentStatement.
     */
    static isCommentStatement(node: compiler.Node): node is compiler.CommentStatement {
        return (node.compilerNode as compiler.CompilerCommentStatement)._commentKind === compiler.CommentNodeKind.Statement;
    }

    /**
     * Gets if the provided node is a CommentClassElement.
     */
    static isCommentClassElement(node: compiler.Node): node is compiler.CommentClassElement {
        return (node.compilerNode as compiler.CompilerCommentClassElement)._commentKind === compiler.CommentNodeKind.ClassElement;
    }

    /**
     * Gets if the provided value is a CommentTypeElement.
     */
    static isCommentTypeElement(node: compiler.Node): node is compiler.CommentTypeElement {
        return (node.compilerNode as compiler.CompilerCommentTypeElement)._commentKind === compiler.CommentNodeKind.TypeElement;
    }

    /**
     * Gets if the provided node is a CommentObjectLiteralElement.
     */
    static isCommentObjectLiteralElement(node: compiler.Node): node is compiler.CommentObjectLiteralElement {
        return (node.compilerNode as compiler.CompilerCommentObjectLiteralElement)._commentKind === compiler.CommentNodeKind.ObjectLiteralElement;
    }

    /**
     * Gets if the provided node is a CommentEnumMember.
     */
    static isCommentEnumMember(node: compiler.Node): node is compiler.CommentEnumMember {
        return (node.compilerNode as compiler.CompilerCommentEnumMember)._commentKind == compiler.CommentNodeKind.EnumMember;
    }

    /**
     * Gets if the node is an AbstractableNode.
     * @param node - Node to check.
     */
    static isAbstractableNode<T extends compiler.Node>(node: T): node is compiler.AbstractableNode & compiler.AbstractableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AmbientableNode.
     * @param node - Node to check.
     */
    static isAmbientableNode<T extends compiler.Node>(node: T): node is compiler.AmbientableNode & compiler.AmbientableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AnyKeyword.
     * @param node - Node to check.
     */
    static isAnyKeyword(node: compiler.Node): node is compiler.Expression {
        return node.getKind() === SyntaxKind.AnyKeyword;
    }

    /**
     * Gets if the node is an ArgumentedNode.
     * @param node - Node to check.
     */
    static isArgumentedNode<T extends compiler.Node>(node: T): node is compiler.ArgumentedNode & compiler.ArgumentedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ArrayBindingPattern.
     * @param node - Node to check.
     */
    static isArrayBindingPattern(node: compiler.Node): node is compiler.ArrayBindingPattern {
        return node.getKind() === SyntaxKind.ArrayBindingPattern;
    }

    /**
     * Gets if the node is an ArrayLiteralExpression.
     * @param node - Node to check.
     */
    static isArrayLiteralExpression(node: compiler.Node): node is compiler.ArrayLiteralExpression {
        return node.getKind() === SyntaxKind.ArrayLiteralExpression;
    }

    /**
     * Gets if the node is an ArrayTypeNode.
     * @param node - Node to check.
     */
    static isArrayTypeNode(node: compiler.Node): node is compiler.ArrayTypeNode {
        return node.getKind() === SyntaxKind.ArrayType;
    }

    /**
     * Gets if the node is an ArrowFunction.
     * @param node - Node to check.
     */
    static isArrowFunction(node: compiler.Node): node is compiler.ArrowFunction {
        return node.getKind() === SyntaxKind.ArrowFunction;
    }

    /**
     * Gets if the node is an AsExpression.
     * @param node - Node to check.
     */
    static isAsExpression(node: compiler.Node): node is compiler.AsExpression {
        return node.getKind() === SyntaxKind.AsExpression;
    }

    /**
     * Gets if the node is an AsyncableNode.
     * @param node - Node to check.
     */
    static isAsyncableNode<T extends compiler.Node>(node: T): node is compiler.AsyncableNode & compiler.AsyncableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AwaitExpression.
     * @param node - Node to check.
     */
    static isAwaitExpression(node: compiler.Node): node is compiler.AwaitExpression {
        return node.getKind() === SyntaxKind.AwaitExpression;
    }

    /**
     * Gets if the node is an AwaitableNode.
     * @param node - Node to check.
     */
    static isAwaitableNode<T extends compiler.Node>(node: T): node is compiler.AwaitableNode & compiler.AwaitableNodeExtensionType & T {
        return node.getKind() === SyntaxKind.ForOfStatement;
    }

    /**
     * Gets if the node is a BinaryExpression.
     * @param node - Node to check.
     */
    static isBinaryExpression(node: compiler.Node): node is compiler.BinaryExpression {
        return node.getKind() === SyntaxKind.BinaryExpression;
    }

    /**
     * Gets if the node is a BindingElement.
     * @param node - Node to check.
     */
    static isBindingElement(node: compiler.Node): node is compiler.BindingElement {
        return node.getKind() === SyntaxKind.BindingElement;
    }

    /**
     * Gets if the node is a BindingNamedNode.
     * @param node - Node to check.
     */
    static isBindingNamedNode<T extends compiler.Node>(node: T): node is compiler.BindingNamedNode & compiler.BindingNamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.Parameter:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Block.
     * @param node - Node to check.
     */
    static isBlock(node: compiler.Node): node is compiler.Block {
        return node.getKind() === SyntaxKind.Block;
    }

    /**
     * Gets if the node is a BodiedNode.
     * @param node - Node to check.
     */
    static isBodiedNode<T extends compiler.Node>(node: T): node is compiler.BodiedNode & compiler.BodiedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BodyableNode.
     * @param node - Node to check.
     */
    static isBodyableNode<T extends compiler.Node>(node: T): node is compiler.BodyableNode & compiler.BodyableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BooleanKeyword.
     * @param node - Node to check.
     */
    static isBooleanKeyword(node: compiler.Node): node is compiler.Expression {
        return node.getKind() === SyntaxKind.BooleanKeyword;
    }

    /**
     * Gets if the node is a BooleanLiteral.
     * @param node - Node to check.
     */
    static isBooleanLiteral(node: compiler.Node): node is compiler.BooleanLiteral {
        switch (node.getKind()) {
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BreakStatement.
     * @param node - Node to check.
     */
    static isBreakStatement(node: compiler.Node): node is compiler.BreakStatement {
        return node.getKind() === SyntaxKind.BreakStatement;
    }

    /**
     * Gets if the node is a CallExpression.
     * @param node - Node to check.
     */
    static isCallExpression(node: compiler.Node): node is compiler.CallExpression {
        return node.getKind() === SyntaxKind.CallExpression;
    }

    /**
     * Gets if the node is a CallSignatureDeclaration.
     * @param node - Node to check.
     */
    static isCallSignatureDeclaration(node: compiler.Node): node is compiler.CallSignatureDeclaration {
        return node.getKind() === SyntaxKind.CallSignature;
    }

    /**
     * Gets if the node is a CaseBlock.
     * @param node - Node to check.
     */
    static isCaseBlock(node: compiler.Node): node is compiler.CaseBlock {
        return node.getKind() === SyntaxKind.CaseBlock;
    }

    /**
     * Gets if the node is a CaseClause.
     * @param node - Node to check.
     */
    static isCaseClause(node: compiler.Node): node is compiler.CaseClause {
        return node.getKind() === SyntaxKind.CaseClause;
    }

    /**
     * Gets if the node is a CatchClause.
     * @param node - Node to check.
     */
    static isCatchClause(node: compiler.Node): node is compiler.CatchClause {
        return node.getKind() === SyntaxKind.CatchClause;
    }

    /**
     * Gets if the node is a ChildOrderableNode.
     * @param node - Node to check.
     */
    static isChildOrderableNode<T extends compiler.Node>(node: T): node is compiler.ChildOrderableNode & compiler.ChildOrderableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.ExportDeclaration:
            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleBlock:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.Block:
            case SyntaxKind.BreakStatement:
            case SyntaxKind.ContinueStatement:
            case SyntaxKind.DebuggerStatement:
            case SyntaxKind.DoStatement:
            case SyntaxKind.EmptyStatement:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.IfStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.NotEmittedStatement:
            case SyntaxKind.ReturnStatement:
            case SyntaxKind.SwitchStatement:
            case SyntaxKind.ThrowStatement:
            case SyntaxKind.TryStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.WhileStatement:
            case SyntaxKind.WithStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ClassDeclaration.
     * @param node - Node to check.
     */
    static isClassDeclaration(node: compiler.Node): node is compiler.ClassDeclaration {
        return node.getKind() === SyntaxKind.ClassDeclaration;
    }

    /**
     * Gets if the node is a ClassExpression.
     * @param node - Node to check.
     */
    static isClassExpression(node: compiler.Node): node is compiler.ClassExpression {
        return node.getKind() === SyntaxKind.ClassExpression;
    }

    /**
     * Gets if the node is a ClassLikeDeclarationBase.
     * @param node - Node to check.
     */
    static isClassLikeDeclarationBase<T extends compiler.Node>(node: T): node is compiler.ClassLikeDeclarationBase & compiler.ClassLikeDeclarationBaseExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a CommaListExpression.
     * @param node - Node to check.
     */
    static isCommaListExpression(node: compiler.Node): node is compiler.CommaListExpression {
        return node.getKind() === SyntaxKind.CommaListExpression;
    }

    /**
     * Gets if the node is a ComputedPropertyName.
     * @param node - Node to check.
     */
    static isComputedPropertyName(node: compiler.Node): node is compiler.ComputedPropertyName {
        return node.getKind() === SyntaxKind.ComputedPropertyName;
    }

    /**
     * Gets if the node is a ConditionalExpression.
     * @param node - Node to check.
     */
    static isConditionalExpression(node: compiler.Node): node is compiler.ConditionalExpression {
        return node.getKind() === SyntaxKind.ConditionalExpression;
    }

    /**
     * Gets if the node is a ConditionalTypeNode.
     * @param node - Node to check.
     */
    static isConditionalTypeNode(node: compiler.Node): node is compiler.ConditionalTypeNode {
        return node.getKind() === SyntaxKind.ConditionalType;
    }

    /**
     * Gets if the node is a ConstructSignatureDeclaration.
     * @param node - Node to check.
     */
    static isConstructSignatureDeclaration(node: compiler.Node): node is compiler.ConstructSignatureDeclaration {
        return node.getKind() === SyntaxKind.ConstructSignature;
    }

    /**
     * Gets if the node is a ConstructorDeclaration.
     * @param node - Node to check.
     */
    static isConstructorDeclaration(node: compiler.Node): node is compiler.ConstructorDeclaration {
        return node.getKind() === SyntaxKind.Constructor;
    }

    /**
     * Gets if the node is a ConstructorTypeNode.
     * @param node - Node to check.
     */
    static isConstructorTypeNode(node: compiler.Node): node is compiler.ConstructorTypeNode {
        return node.getKind() === SyntaxKind.ConstructorType;
    }

    /**
     * Gets if the node is a ContinueStatement.
     * @param node - Node to check.
     */
    static isContinueStatement(node: compiler.Node): node is compiler.ContinueStatement {
        return node.getKind() === SyntaxKind.ContinueStatement;
    }

    /**
     * Gets if the node is a DebuggerStatement.
     * @param node - Node to check.
     */
    static isDebuggerStatement(node: compiler.Node): node is compiler.DebuggerStatement {
        return node.getKind() === SyntaxKind.DebuggerStatement;
    }

    /**
     * Gets if the node is a DecoratableNode.
     * @param node - Node to check.
     */
    static isDecoratableNode<T extends compiler.Node>(node: T): node is compiler.DecoratableNode & compiler.DecoratableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Decorator.
     * @param node - Node to check.
     */
    static isDecorator(node: compiler.Node): node is compiler.Decorator {
        return node.getKind() === SyntaxKind.Decorator;
    }

    /**
     * Gets if the node is a DefaultClause.
     * @param node - Node to check.
     */
    static isDefaultClause(node: compiler.Node): node is compiler.DefaultClause {
        return node.getKind() === SyntaxKind.DefaultClause;
    }

    /**
     * Gets if the node is a DeleteExpression.
     * @param node - Node to check.
     */
    static isDeleteExpression(node: compiler.Node): node is compiler.DeleteExpression {
        return node.getKind() === SyntaxKind.DeleteExpression;
    }

    /**
     * Gets if the node is a DoStatement.
     * @param node - Node to check.
     */
    static isDoStatement(node: compiler.Node): node is compiler.DoStatement {
        return node.getKind() === SyntaxKind.DoStatement;
    }

    /**
     * Gets if the node is an ElementAccessExpression.
     * @param node - Node to check.
     */
    static isElementAccessExpression(node: compiler.Node): node is compiler.ElementAccessExpression {
        return node.getKind() === SyntaxKind.ElementAccessExpression;
    }

    /**
     * Gets if the node is an EmptyStatement.
     * @param node - Node to check.
     */
    static isEmptyStatement(node: compiler.Node): node is compiler.EmptyStatement {
        return node.getKind() === SyntaxKind.EmptyStatement;
    }

    /**
     * Gets if the node is an EnumDeclaration.
     * @param node - Node to check.
     */
    static isEnumDeclaration(node: compiler.Node): node is compiler.EnumDeclaration {
        return node.getKind() === SyntaxKind.EnumDeclaration;
    }

    /**
     * Gets if the node is an EnumMember.
     * @param node - Node to check.
     */
    static isEnumMember(node: compiler.Node): node is compiler.EnumMember {
        return node.getKind() === SyntaxKind.EnumMember;
    }

    /**
     * Gets if the node is an ExclamationTokenableNode.
     * @param node - Node to check.
     */
    static isExclamationTokenableNode<T extends compiler.Node>(node: T): node is compiler.ExclamationTokenableNode & compiler.ExclamationTokenableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExportAssignment.
     * @param node - Node to check.
     */
    static isExportAssignment(node: compiler.Node): node is compiler.ExportAssignment {
        return node.getKind() === SyntaxKind.ExportAssignment;
    }

    /**
     * Gets if the node is an ExportDeclaration.
     * @param node - Node to check.
     */
    static isExportDeclaration(node: compiler.Node): node is compiler.ExportDeclaration {
        return node.getKind() === SyntaxKind.ExportDeclaration;
    }

    /**
     * Gets if the node is an ExportGetableNode.
     * @param node - Node to check.
     */
    static isExportGetableNode<T extends compiler.Node>(node: T): node is compiler.ExportGetableNode & compiler.ExportGetableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExportSpecifier.
     * @param node - Node to check.
     */
    static isExportSpecifier(node: compiler.Node): node is compiler.ExportSpecifier {
        return node.getKind() === SyntaxKind.ExportSpecifier;
    }

    /**
     * Gets if the node is an ExportableNode.
     * @param node - Node to check.
     */
    static isExportableNode<T extends compiler.Node>(node: T): node is compiler.ExportableNode & compiler.ExportableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an Expression.
     * @param node - Node to check.
     */
    static isExpression(node: compiler.Node): node is compiler.Expression {
        switch (node.getKind()) {
            case SyntaxKind.AnyKeyword:
            case SyntaxKind.BooleanKeyword:
            case SyntaxKind.NeverKeyword:
            case SyntaxKind.NumberKeyword:
            case SyntaxKind.ObjectKeyword:
            case SyntaxKind.StringKeyword:
            case SyntaxKind.SymbolKeyword:
            case SyntaxKind.UndefinedKeyword:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.AsExpression:
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.BinaryExpression:
            case SyntaxKind.CallExpression:
            case SyntaxKind.CommaListExpression:
            case SyntaxKind.ConditionalExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.OmittedExpression:
            case SyntaxKind.ParenthesizedExpression:
            case SyntaxKind.PartiallyEmittedExpression:
            case SyntaxKind.PostfixUnaryExpression:
            case SyntaxKind.PrefixUnaryExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SpreadElement:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidExpression:
            case SyntaxKind.YieldExpression:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxClosingFragment:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxExpression:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxOpeningFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExpressionStatement.
     * @param node - Node to check.
     */
    static isExpressionStatement(node: compiler.Node): node is compiler.ExpressionStatement {
        return node.getKind() === SyntaxKind.ExpressionStatement;
    }

    /**
     * Gets if the node is an ExpressionWithTypeArguments.
     * @param node - Node to check.
     */
    static isExpressionWithTypeArguments(node: compiler.Node): node is compiler.ExpressionWithTypeArguments {
        return node.getKind() === SyntaxKind.ExpressionWithTypeArguments;
    }

    /**
     * Gets if the node is an ExpressionedNode.
     * @param node - Node to check.
     */
    static isExpressionedNode<T extends compiler.Node>(node: T): node is compiler.ExpressionedNode & compiler.ExpressionedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.AsExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.ParenthesizedExpression:
            case SyntaxKind.PartiallyEmittedExpression:
            case SyntaxKind.SpreadElement:
            case SyntaxKind.SpreadAssignment:
            case SyntaxKind.TemplateSpan:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExtendsClauseableNode.
     * @param node - Node to check.
     */
    static isExtendsClauseableNode<T extends compiler.Node>(node: T): node is compiler.ExtendsClauseableNode & compiler.ExtendsClauseableNodeExtensionType & T {
        return node.getKind() === SyntaxKind.InterfaceDeclaration;
    }

    /**
     * Gets if the node is an ExternalModuleReference.
     * @param node - Node to check.
     */
    static isExternalModuleReference(node: compiler.Node): node is compiler.ExternalModuleReference {
        return node.getKind() === SyntaxKind.ExternalModuleReference;
    }

    /**
     * Gets if the node is a FalseKeyword.
     * @param node - Node to check.
     */
    static isFalseKeyword(node: compiler.Node): node is compiler.BooleanLiteral {
        return node.getKind() === SyntaxKind.FalseKeyword;
    }

    /**
     * Gets if the node is a ForInStatement.
     * @param node - Node to check.
     */
    static isForInStatement(node: compiler.Node): node is compiler.ForInStatement {
        return node.getKind() === SyntaxKind.ForInStatement;
    }

    /**
     * Gets if the node is a ForOfStatement.
     * @param node - Node to check.
     */
    static isForOfStatement(node: compiler.Node): node is compiler.ForOfStatement {
        return node.getKind() === SyntaxKind.ForOfStatement;
    }

    /**
     * Gets if the node is a ForStatement.
     * @param node - Node to check.
     */
    static isForStatement(node: compiler.Node): node is compiler.ForStatement {
        return node.getKind() === SyntaxKind.ForStatement;
    }

    /**
     * Gets if the node is a FunctionDeclaration.
     * @param node - Node to check.
     */
    static isFunctionDeclaration(node: compiler.Node): node is compiler.FunctionDeclaration {
        return node.getKind() === SyntaxKind.FunctionDeclaration;
    }

    /**
     * Gets if the node is a FunctionExpression.
     * @param node - Node to check.
     */
    static isFunctionExpression(node: compiler.Node): node is compiler.FunctionExpression {
        return node.getKind() === SyntaxKind.FunctionExpression;
    }

    /**
     * Gets if the node is a FunctionLikeDeclaration.
     * @param node - Node to check.
     */
    static isFunctionLikeDeclaration<T extends compiler.Node>(node: T): node is compiler.FunctionLikeDeclaration & compiler.FunctionLikeDeclarationExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a FunctionTypeNode.
     * @param node - Node to check.
     */
    static isFunctionTypeNode(node: compiler.Node): node is compiler.FunctionTypeNode {
        return node.getKind() === SyntaxKind.FunctionType;
    }

    /**
     * Gets if the node is a GeneratorableNode.
     * @param node - Node to check.
     */
    static isGeneratorableNode<T extends compiler.Node>(node: T): node is compiler.GeneratorableNode & compiler.GeneratorableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.YieldExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a GetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isGetAccessorDeclaration(node: compiler.Node): node is compiler.GetAccessorDeclaration {
        return node.getKind() === SyntaxKind.GetAccessor;
    }

    /**
     * Gets if the node is a HeritageClause.
     * @param node - Node to check.
     */
    static isHeritageClause(node: compiler.Node): node is compiler.HeritageClause {
        return node.getKind() === SyntaxKind.HeritageClause;
    }

    /**
     * Gets if the node is a HeritageClauseableNode.
     * @param node - Node to check.
     */
    static isHeritageClauseableNode<T extends compiler.Node>(node: T): node is compiler.HeritageClauseableNode & compiler.HeritageClauseableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Identifier.
     * @param node - Node to check.
     */
    static isIdentifier(node: compiler.Node): node is compiler.Identifier {
        return node.getKind() === SyntaxKind.Identifier;
    }

    /**
     * Gets if the node is a IfStatement.
     * @param node - Node to check.
     */
    static isIfStatement(node: compiler.Node): node is compiler.IfStatement {
        return node.getKind() === SyntaxKind.IfStatement;
    }

    /**
     * Gets if the node is a ImplementsClauseableNode.
     * @param node - Node to check.
     */
    static isImplementsClauseableNode<T extends compiler.Node>(node: T): node is compiler.ImplementsClauseableNode & compiler.ImplementsClauseableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ImportClause.
     * @param node - Node to check.
     */
    static isImportClause(node: compiler.Node): node is compiler.ImportClause {
        return node.getKind() === SyntaxKind.ImportClause;
    }

    /**
     * Gets if the node is a ImportDeclaration.
     * @param node - Node to check.
     */
    static isImportDeclaration(node: compiler.Node): node is compiler.ImportDeclaration {
        return node.getKind() === SyntaxKind.ImportDeclaration;
    }

    /**
     * Gets if the node is a ImportEqualsDeclaration.
     * @param node - Node to check.
     */
    static isImportEqualsDeclaration(node: compiler.Node): node is compiler.ImportEqualsDeclaration {
        return node.getKind() === SyntaxKind.ImportEqualsDeclaration;
    }

    /**
     * Gets if the node is a ImportExpression.
     * @param node - Node to check.
     */
    static isImportExpression(node: compiler.Node): node is compiler.ImportExpression {
        return node.getKind() === SyntaxKind.ImportKeyword;
    }

    /**
     * Gets if the node is a ImportSpecifier.
     * @param node - Node to check.
     */
    static isImportSpecifier(node: compiler.Node): node is compiler.ImportSpecifier {
        return node.getKind() === SyntaxKind.ImportSpecifier;
    }

    /**
     * Gets if the node is a ImportTypeNode.
     * @param node - Node to check.
     */
    static isImportTypeNode(node: compiler.Node): node is compiler.ImportTypeNode {
        return node.getKind() === SyntaxKind.ImportType;
    }

    /**
     * Gets if the node is a IndexSignatureDeclaration.
     * @param node - Node to check.
     */
    static isIndexSignatureDeclaration(node: compiler.Node): node is compiler.IndexSignatureDeclaration {
        return node.getKind() === SyntaxKind.IndexSignature;
    }

    /**
     * Gets if the node is a IndexedAccessTypeNode.
     * @param node - Node to check.
     */
    static isIndexedAccessTypeNode(node: compiler.Node): node is compiler.IndexedAccessTypeNode {
        return node.getKind() === SyntaxKind.IndexedAccessType;
    }

    /**
     * Gets if the node is a InferKeyword.
     * @param node - Node to check.
     */
    static isInferKeyword(node: compiler.Node): node is compiler.Node {
        return node.getKind() === SyntaxKind.InferKeyword;
    }

    /**
     * Gets if the node is a InferTypeNode.
     * @param node - Node to check.
     */
    static isInferTypeNode(node: compiler.Node): node is compiler.InferTypeNode {
        return node.getKind() === SyntaxKind.InferType;
    }

    /**
     * Gets if the node is a InitializerExpressionGetableNode.
     * @param node - Node to check.
     */
    static isInitializerExpressionGetableNode<T extends compiler.Node>(node: T): node is compiler.InitializerExpressionGetableNode & compiler.InitializerExpressionGetableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a InitializerExpressionableNode.
     * @param node - Node to check.
     */
    static isInitializerExpressionableNode<T extends compiler.Node>(node: T): node is compiler.InitializerExpressionableNode & compiler.InitializerExpressionableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a InterfaceDeclaration.
     * @param node - Node to check.
     */
    static isInterfaceDeclaration(node: compiler.Node): node is compiler.InterfaceDeclaration {
        return node.getKind() === SyntaxKind.InterfaceDeclaration;
    }

    /**
     * Gets if the node is a IntersectionTypeNode.
     * @param node - Node to check.
     */
    static isIntersectionTypeNode(node: compiler.Node): node is compiler.IntersectionTypeNode {
        return node.getKind() === SyntaxKind.IntersectionType;
    }

    /**
     * Gets if the node is a IterationStatement.
     * @param node - Node to check.
     */
    static isIterationStatement(node: compiler.Node): node is compiler.IterationStatement {
        switch (node.getKind()) {
            case SyntaxKind.DoStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.WhileStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDoc.
     * @param node - Node to check.
     */
    static isJSDoc(node: compiler.Node): node is compiler.JSDoc {
        return node.getKind() === SyntaxKind.JSDocComment;
    }

    /**
     * Gets if the node is a JSDocAugmentsTag.
     * @param node - Node to check.
     */
    static isJSDocAugmentsTag(node: compiler.Node): node is compiler.JSDocAugmentsTag {
        return node.getKind() === SyntaxKind.JSDocAugmentsTag;
    }

    /**
     * Gets if the node is a JSDocClassTag.
     * @param node - Node to check.
     */
    static isJSDocClassTag(node: compiler.Node): node is compiler.JSDocClassTag {
        return node.getKind() === SyntaxKind.JSDocClassTag;
    }

    /**
     * Gets if the node is a JSDocFunctionType.
     * @param node - Node to check.
     */
    static isJSDocFunctionType(node: compiler.Node): node is compiler.JSDocFunctionType {
        return node.getKind() === SyntaxKind.JSDocFunctionType;
    }

    /**
     * Gets if the node is a JSDocParameterTag.
     * @param node - Node to check.
     */
    static isJSDocParameterTag(node: compiler.Node): node is compiler.JSDocParameterTag {
        return node.getKind() === SyntaxKind.JSDocParameterTag;
    }

    /**
     * Gets if the node is a JSDocPropertyLikeTag.
     * @param node - Node to check.
     */
    static isJSDocPropertyLikeTag<T extends compiler.Node>(node: T): node is compiler.JSDocPropertyLikeTag & compiler.JSDocPropertyLikeTagExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JSDocParameterTag:
            case SyntaxKind.JSDocPropertyTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocPropertyTag.
     * @param node - Node to check.
     */
    static isJSDocPropertyTag(node: compiler.Node): node is compiler.JSDocPropertyTag {
        return node.getKind() === SyntaxKind.JSDocPropertyTag;
    }

    /**
     * Gets if the node is a JSDocReturnTag.
     * @param node - Node to check.
     */
    static isJSDocReturnTag(node: compiler.Node): node is compiler.JSDocReturnTag {
        return node.getKind() === SyntaxKind.JSDocReturnTag;
    }

    /**
     * Gets if the node is a JSDocSignature.
     * @param node - Node to check.
     */
    static isJSDocSignature(node: compiler.Node): node is compiler.JSDocSignature {
        return node.getKind() === SyntaxKind.JSDocSignature;
    }

    /**
     * Gets if the node is a JSDocTag.
     * @param node - Node to check.
     */
    static isJSDocTag(node: compiler.Node): node is compiler.JSDocTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocAugmentsTag:
            case SyntaxKind.JSDocClassTag:
            case SyntaxKind.JSDocParameterTag:
            case SyntaxKind.JSDocPropertyTag:
            case SyntaxKind.JSDocReturnTag:
            case SyntaxKind.JSDocTypedefTag:
            case SyntaxKind.JSDocTypeTag:
            case SyntaxKind.JSDocTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocType.
     * @param node - Node to check.
     */
    static isJSDocType(node: compiler.Node): node is compiler.JSDocType {
        switch (node.getKind()) {
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.JSDocSignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocTypeExpression.
     * @param node - Node to check.
     */
    static isJSDocTypeExpression(node: compiler.Node): node is compiler.JSDocTypeExpression {
        return node.getKind() === SyntaxKind.JSDocTypeExpression;
    }

    /**
     * Gets if the node is a JSDocTypeTag.
     * @param node - Node to check.
     */
    static isJSDocTypeTag(node: compiler.Node): node is compiler.JSDocTypeTag {
        return node.getKind() === SyntaxKind.JSDocTypeTag;
    }

    /**
     * Gets if the node is a JSDocTypedefTag.
     * @param node - Node to check.
     */
    static isJSDocTypedefTag(node: compiler.Node): node is compiler.JSDocTypedefTag {
        return node.getKind() === SyntaxKind.JSDocTypedefTag;
    }

    /**
     * Gets if the node is a JSDocUnknownTag.
     * @param node - Node to check.
     */
    static isJSDocUnknownTag(node: compiler.Node): node is compiler.JSDocUnknownTag {
        return node.getKind() === SyntaxKind.JSDocTag;
    }

    /**
     * Gets if the node is a JSDocableNode.
     * @param node - Node to check.
     */
    static isJSDocableNode<T extends compiler.Node>(node: T): node is compiler.JSDocableNode & compiler.JSDocableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxAttribute.
     * @param node - Node to check.
     */
    static isJsxAttribute(node: compiler.Node): node is compiler.JsxAttribute {
        return node.getKind() === SyntaxKind.JsxAttribute;
    }

    /**
     * Gets if the node is a JsxAttributedNode.
     * @param node - Node to check.
     */
    static isJsxAttributedNode<T extends compiler.Node>(node: T): node is compiler.JsxAttributedNode & compiler.JsxAttributedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxClosingElement.
     * @param node - Node to check.
     */
    static isJsxClosingElement(node: compiler.Node): node is compiler.JsxClosingElement {
        return node.getKind() === SyntaxKind.JsxClosingElement;
    }

    /**
     * Gets if the node is a JsxClosingFragment.
     * @param node - Node to check.
     */
    static isJsxClosingFragment(node: compiler.Node): node is compiler.JsxClosingFragment {
        return node.getKind() === SyntaxKind.JsxClosingFragment;
    }

    /**
     * Gets if the node is a JsxElement.
     * @param node - Node to check.
     */
    static isJsxElement(node: compiler.Node): node is compiler.JsxElement {
        return node.getKind() === SyntaxKind.JsxElement;
    }

    /**
     * Gets if the node is a JsxExpression.
     * @param node - Node to check.
     */
    static isJsxExpression(node: compiler.Node): node is compiler.JsxExpression {
        return node.getKind() === SyntaxKind.JsxExpression;
    }

    /**
     * Gets if the node is a JsxFragment.
     * @param node - Node to check.
     */
    static isJsxFragment(node: compiler.Node): node is compiler.JsxFragment {
        return node.getKind() === SyntaxKind.JsxFragment;
    }

    /**
     * Gets if the node is a JsxOpeningElement.
     * @param node - Node to check.
     */
    static isJsxOpeningElement(node: compiler.Node): node is compiler.JsxOpeningElement {
        return node.getKind() === SyntaxKind.JsxOpeningElement;
    }

    /**
     * Gets if the node is a JsxOpeningFragment.
     * @param node - Node to check.
     */
    static isJsxOpeningFragment(node: compiler.Node): node is compiler.JsxOpeningFragment {
        return node.getKind() === SyntaxKind.JsxOpeningFragment;
    }

    /**
     * Gets if the node is a JsxSelfClosingElement.
     * @param node - Node to check.
     */
    static isJsxSelfClosingElement(node: compiler.Node): node is compiler.JsxSelfClosingElement {
        return node.getKind() === SyntaxKind.JsxSelfClosingElement;
    }

    /**
     * Gets if the node is a JsxSpreadAttribute.
     * @param node - Node to check.
     */
    static isJsxSpreadAttribute(node: compiler.Node): node is compiler.JsxSpreadAttribute {
        return node.getKind() === SyntaxKind.JsxSpreadAttribute;
    }

    /**
     * Gets if the node is a JsxTagNamedNode.
     * @param node - Node to check.
     */
    static isJsxTagNamedNode<T extends compiler.Node>(node: T): node is compiler.JsxTagNamedNode & compiler.JsxTagNamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JsxClosingElement:
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxText.
     * @param node - Node to check.
     */
    static isJsxText(node: compiler.Node): node is compiler.JsxText {
        return node.getKind() === SyntaxKind.JsxText;
    }

    /**
     * Gets if the node is a LabeledStatement.
     * @param node - Node to check.
     */
    static isLabeledStatement(node: compiler.Node): node is compiler.LabeledStatement {
        return node.getKind() === SyntaxKind.LabeledStatement;
    }

    /**
     * Gets if the node is a LeftHandSideExpression.
     * @param node - Node to check.
     */
    static isLeftHandSideExpression(node: compiler.Node): node is compiler.LeftHandSideExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LeftHandSideExpressionedNode.
     * @param node - Node to check.
     */
    static isLeftHandSideExpressionedNode<T extends compiler.Node>(node: T): node is compiler.LeftHandSideExpressionedNode & compiler.LeftHandSideExpressionedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.NewExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ExpressionWithTypeArguments:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralExpression.
     * @param node - Node to check.
     */
    static isLiteralExpression(node: compiler.Node): node is compiler.LiteralExpression {
        switch (node.getKind()) {
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralLikeNode.
     * @param node - Node to check.
     */
    static isLiteralLikeNode<T extends compiler.Node>(node: T): node is compiler.LiteralLikeNode & compiler.LiteralLikeNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JsxText:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TemplateHead:
            case SyntaxKind.TemplateMiddle:
            case SyntaxKind.TemplateTail:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralTypeNode.
     * @param node - Node to check.
     */
    static isLiteralTypeNode(node: compiler.Node): node is compiler.LiteralTypeNode {
        return node.getKind() === SyntaxKind.LiteralType;
    }

    /**
     * Gets if the node is a MemberExpression.
     * @param node - Node to check.
     */
    static isMemberExpression(node: compiler.Node): node is compiler.MemberExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a MetaProperty.
     * @param node - Node to check.
     */
    static isMetaProperty(node: compiler.Node): node is compiler.MetaProperty {
        return node.getKind() === SyntaxKind.MetaProperty;
    }

    /**
     * Gets if the node is a MethodDeclaration.
     * @param node - Node to check.
     */
    static isMethodDeclaration(node: compiler.Node): node is compiler.MethodDeclaration {
        return node.getKind() === SyntaxKind.MethodDeclaration;
    }

    /**
     * Gets if the node is a MethodSignature.
     * @param node - Node to check.
     */
    static isMethodSignature(node: compiler.Node): node is compiler.MethodSignature {
        return node.getKind() === SyntaxKind.MethodSignature;
    }

    /**
     * Gets if the node is a ModifierableNode.
     * @param node - Node to check.
     */
    static isModifierableNode<T extends compiler.Node>(node: T): node is compiler.ModifierableNode & compiler.ModifierableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.VariableDeclarationList:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ModuleBlock.
     * @param node - Node to check.
     */
    static isModuleBlock(node: compiler.Node): node is compiler.ModuleBlock {
        return node.getKind() === SyntaxKind.ModuleBlock;
    }

    /**
     * Gets if the node is a ModuledNode.
     * @param node - Node to check.
     */
    static isModuledNode<T extends compiler.Node>(node: T): node is compiler.ModuledNode & compiler.ModuledNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NameableNode.
     * @param node - Node to check.
     */
    static isNameableNode<T extends compiler.Node>(node: T): node is compiler.NameableNode & compiler.NameableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamedExports.
     * @param node - Node to check.
     */
    static isNamedExports(node: compiler.Node): node is compiler.NamedExports {
        return node.getKind() === SyntaxKind.NamedExports;
    }

    /**
     * Gets if the node is a NamedImports.
     * @param node - Node to check.
     */
    static isNamedImports(node: compiler.Node): node is compiler.NamedImports {
        return node.getKind() === SyntaxKind.NamedImports;
    }

    /**
     * Gets if the node is a NamedNode.
     * @param node - Node to check.
     */
    static isNamedNode<T extends compiler.Node>(node: T): node is compiler.NamedNode & compiler.NamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamespaceChildableNode.
     * @param node - Node to check.
     */
    static isNamespaceChildableNode<T extends compiler.Node>(node: T): node is compiler.NamespaceChildableNode & compiler.NamespaceChildableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamespaceDeclaration.
     * @param node - Node to check.
     */
    static isNamespaceDeclaration(node: compiler.Node): node is compiler.NamespaceDeclaration {
        return node.getKind() === SyntaxKind.ModuleDeclaration;
    }

    /**
     * Gets if the node is a NamespaceImport.
     * @param node - Node to check.
     */
    static isNamespaceImport(node: compiler.Node): node is compiler.NamespaceImport {
        return node.getKind() === SyntaxKind.NamespaceImport;
    }

    /**
     * Gets if the node is a NeverKeyword.
     * @param node - Node to check.
     */
    static isNeverKeyword(node: compiler.Node): node is compiler.Expression {
        return node.getKind() === SyntaxKind.NeverKeyword;
    }

    /**
     * Gets if the node is a NewExpression.
     * @param node - Node to check.
     */
    static isNewExpression(node: compiler.Node): node is compiler.NewExpression {
        return node.getKind() === SyntaxKind.NewExpression;
    }

    /**
     * Gets if the node is a NoSubstitutionTemplateLiteral.
     * @param node - Node to check.
     */
    static isNoSubstitutionTemplateLiteral(node: compiler.Node): node is compiler.NoSubstitutionTemplateLiteral {
        return node.getKind() === SyntaxKind.NoSubstitutionTemplateLiteral;
    }

    /**
     * Gets if the node is a NonNullExpression.
     * @param node - Node to check.
     */
    static isNonNullExpression(node: compiler.Node): node is compiler.NonNullExpression {
        return node.getKind() === SyntaxKind.NonNullExpression;
    }

    /**
     * Gets if the node is a NotEmittedStatement.
     * @param node - Node to check.
     */
    static isNotEmittedStatement(node: compiler.Node): node is compiler.NotEmittedStatement {
        return node.getKind() === SyntaxKind.NotEmittedStatement;
    }

    /**
     * Gets if the node is a NullLiteral.
     * @param node - Node to check.
     */
    static isNullLiteral(node: compiler.Node): node is compiler.NullLiteral {
        return node.getKind() === SyntaxKind.NullKeyword;
    }

    /**
     * Gets if the node is a NumberKeyword.
     * @param node - Node to check.
     */
    static isNumberKeyword(node: compiler.Node): node is compiler.Expression {
        return node.getKind() === SyntaxKind.NumberKeyword;
    }

    /**
     * Gets if the node is a NumericLiteral.
     * @param node - Node to check.
     */
    static isNumericLiteral(node: compiler.Node): node is compiler.NumericLiteral {
        return node.getKind() === SyntaxKind.NumericLiteral;
    }

    /**
     * Gets if the node is a ObjectBindingPattern.
     * @param node - Node to check.
     */
    static isObjectBindingPattern(node: compiler.Node): node is compiler.ObjectBindingPattern {
        return node.getKind() === SyntaxKind.ObjectBindingPattern;
    }

    /**
     * Gets if the node is a ObjectKeyword.
     * @param node - Node to check.
     */
    static isObjectKeyword(node: compiler.Node): node is compiler.Expression {
        return node.getKind() === SyntaxKind.ObjectKeyword;
    }

    /**
     * Gets if the node is a ObjectLiteralExpression.
     * @param node - Node to check.
     */
    static isObjectLiteralExpression(node: compiler.Node): node is compiler.ObjectLiteralExpression {
        return node.getKind() === SyntaxKind.ObjectLiteralExpression;
    }

    /**
     * Gets if the node is a OmittedExpression.
     * @param node - Node to check.
     */
    static isOmittedExpression(node: compiler.Node): node is compiler.OmittedExpression {
        return node.getKind() === SyntaxKind.OmittedExpression;
    }

    /**
     * Gets if the node is a OverloadableNode.
     * @param node - Node to check.
     */
    static isOverloadableNode<T extends compiler.Node>(node: T): node is compiler.OverloadableNode & compiler.OverloadableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ParameterDeclaration.
     * @param node - Node to check.
     */
    static isParameterDeclaration(node: compiler.Node): node is compiler.ParameterDeclaration {
        return node.getKind() === SyntaxKind.Parameter;
    }

    /**
     * Gets if the node is a ParameteredNode.
     * @param node - Node to check.
     */
    static isParameteredNode<T extends compiler.Node>(node: T): node is compiler.ParameteredNode & compiler.ParameteredNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ParenthesizedExpression.
     * @param node - Node to check.
     */
    static isParenthesizedExpression(node: compiler.Node): node is compiler.ParenthesizedExpression {
        return node.getKind() === SyntaxKind.ParenthesizedExpression;
    }

    /**
     * Gets if the node is a ParenthesizedTypeNode.
     * @param node - Node to check.
     */
    static isParenthesizedTypeNode(node: compiler.Node): node is compiler.ParenthesizedTypeNode {
        return node.getKind() === SyntaxKind.ParenthesizedType;
    }

    /**
     * Gets if the node is a PartiallyEmittedExpression.
     * @param node - Node to check.
     */
    static isPartiallyEmittedExpression(node: compiler.Node): node is compiler.PartiallyEmittedExpression {
        return node.getKind() === SyntaxKind.PartiallyEmittedExpression;
    }

    /**
     * Gets if the node is a PostfixUnaryExpression.
     * @param node - Node to check.
     */
    static isPostfixUnaryExpression(node: compiler.Node): node is compiler.PostfixUnaryExpression {
        return node.getKind() === SyntaxKind.PostfixUnaryExpression;
    }

    /**
     * Gets if the node is a PrefixUnaryExpression.
     * @param node - Node to check.
     */
    static isPrefixUnaryExpression(node: compiler.Node): node is compiler.PrefixUnaryExpression {
        return node.getKind() === SyntaxKind.PrefixUnaryExpression;
    }

    /**
     * Gets if the node is a PrimaryExpression.
     * @param node - Node to check.
     */
    static isPrimaryExpression(node: compiler.Node): node is compiler.PrimaryExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PropertyAccessExpression.
     * @param node - Node to check.
     */
    static isPropertyAccessExpression(node: compiler.Node): node is compiler.PropertyAccessExpression {
        return node.getKind() === SyntaxKind.PropertyAccessExpression;
    }

    /**
     * Gets if the node is a PropertyAssignment.
     * @param node - Node to check.
     */
    static isPropertyAssignment(node: compiler.Node): node is compiler.PropertyAssignment {
        return node.getKind() === SyntaxKind.PropertyAssignment;
    }

    /**
     * Gets if the node is a PropertyDeclaration.
     * @param node - Node to check.
     */
    static isPropertyDeclaration(node: compiler.Node): node is compiler.PropertyDeclaration {
        return node.getKind() === SyntaxKind.PropertyDeclaration;
    }

    /**
     * Gets if the node is a PropertyNamedNode.
     * @param node - Node to check.
     */
    static isPropertyNamedNode<T extends compiler.Node>(node: T): node is compiler.PropertyNamedNode & compiler.PropertyNamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumMember:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.PropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PropertySignature.
     * @param node - Node to check.
     */
    static isPropertySignature(node: compiler.Node): node is compiler.PropertySignature {
        return node.getKind() === SyntaxKind.PropertySignature;
    }

    /**
     * Gets if the node is a QualifiedName.
     * @param node - Node to check.
     */
    static isQualifiedName(node: compiler.Node): node is compiler.QualifiedName {
        return node.getKind() === SyntaxKind.QualifiedName;
    }

    /**
     * Gets if the node is a QuestionTokenableNode.
     * @param node - Node to check.
     */
    static isQuestionTokenableNode<T extends compiler.Node>(node: T): node is compiler.QuestionTokenableNode & compiler.QuestionTokenableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReadonlyableNode.
     * @param node - Node to check.
     */
    static isReadonlyableNode<T extends compiler.Node>(node: T): node is compiler.ReadonlyableNode & compiler.ReadonlyableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReferenceFindableNode.
     * @param node - Node to check.
     */
    static isReferenceFindableNode<T extends compiler.Node>(node: T): node is compiler.ReferenceFindableNode & compiler.ReferenceFindableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Identifier:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a RegularExpressionLiteral.
     * @param node - Node to check.
     */
    static isRegularExpressionLiteral(node: compiler.Node): node is compiler.RegularExpressionLiteral {
        return node.getKind() === SyntaxKind.RegularExpressionLiteral;
    }

    /**
     * Gets if the node is a RenameableNode.
     * @param node - Node to check.
     */
    static isRenameableNode<T extends compiler.Node>(node: T): node is compiler.RenameableNode & compiler.RenameableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Identifier:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.NamespaceImport:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReturnStatement.
     * @param node - Node to check.
     */
    static isReturnStatement(node: compiler.Node): node is compiler.ReturnStatement {
        return node.getKind() === SyntaxKind.ReturnStatement;
    }

    /**
     * Gets if the node is a ReturnTypedNode.
     * @param node - Node to check.
     */
    static isReturnTypedNode<T extends compiler.Node>(node: T): node is compiler.ReturnTypedNode & compiler.ReturnTypedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ScopeableNode.
     * @param node - Node to check.
     */
    static isScopeableNode<T extends compiler.Node>(node: T): node is compiler.ScopeableNode & compiler.ScopeableNodeExtensionType & T {
        return node.getKind() === SyntaxKind.Parameter;
    }

    /**
     * Gets if the node is a ScopedNode.
     * @param node - Node to check.
     */
    static isScopedNode<T extends compiler.Node>(node: T): node is compiler.ScopedNode & compiler.ScopedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SemicolonToken.
     * @param node - Node to check.
     */
    static isSemicolonToken(node: compiler.Node): node is compiler.Node {
        return node.getKind() === SyntaxKind.SemicolonToken;
    }

    /**
     * Gets if the node is a SetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isSetAccessorDeclaration(node: compiler.Node): node is compiler.SetAccessorDeclaration {
        return node.getKind() === SyntaxKind.SetAccessor;
    }

    /**
     * Gets if the node is a ShorthandPropertyAssignment.
     * @param node - Node to check.
     */
    static isShorthandPropertyAssignment(node: compiler.Node): node is compiler.ShorthandPropertyAssignment {
        return node.getKind() === SyntaxKind.ShorthandPropertyAssignment;
    }

    /**
     * Gets if the node is a SignaturedDeclaration.
     * @param node - Node to check.
     */
    static isSignaturedDeclaration<T extends compiler.Node>(node: T): node is compiler.SignaturedDeclaration & compiler.SignaturedDeclarationExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SourceFile.
     * @param node - Node to check.
     */
    static isSourceFile(node: compiler.Node): node is compiler.SourceFile {
        return node.getKind() === SyntaxKind.SourceFile;
    }

    /**
     * Gets if the node is a SpreadAssignment.
     * @param node - Node to check.
     */
    static isSpreadAssignment(node: compiler.Node): node is compiler.SpreadAssignment {
        return node.getKind() === SyntaxKind.SpreadAssignment;
    }

    /**
     * Gets if the node is a SpreadElement.
     * @param node - Node to check.
     */
    static isSpreadElement(node: compiler.Node): node is compiler.SpreadElement {
        return node.getKind() === SyntaxKind.SpreadElement;
    }

    /**
     * Gets if the node is a Statement.
     * @param node - Node to check.
     */
    static isStatement(node: compiler.Node): node is compiler.Statement {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.ExportDeclaration:
            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleBlock:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.Block:
            case SyntaxKind.BreakStatement:
            case SyntaxKind.ContinueStatement:
            case SyntaxKind.DebuggerStatement:
            case SyntaxKind.DoStatement:
            case SyntaxKind.EmptyStatement:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.IfStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.NotEmittedStatement:
            case SyntaxKind.ReturnStatement:
            case SyntaxKind.SwitchStatement:
            case SyntaxKind.ThrowStatement:
            case SyntaxKind.TryStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.WhileStatement:
            case SyntaxKind.WithStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StatementedNode.
     * @param node - Node to check.
     */
    static isStatementedNode<T extends compiler.Node>(node: T): node is compiler.StatementedNode & compiler.StatementedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ModuleBlock:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
            case SyntaxKind.Block:
            case SyntaxKind.CaseClause:
            case SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StaticableNode.
     * @param node - Node to check.
     */
    static isStaticableNode<T extends compiler.Node>(node: T): node is compiler.StaticableNode & compiler.StaticableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StringKeyword.
     * @param node - Node to check.
     */
    static isStringKeyword(node: compiler.Node): node is compiler.Expression {
        return node.getKind() === SyntaxKind.StringKeyword;
    }

    /**
     * Gets if the node is a StringLiteral.
     * @param node - Node to check.
     */
    static isStringLiteral(node: compiler.Node): node is compiler.StringLiteral {
        return node.getKind() === SyntaxKind.StringLiteral;
    }

    /**
     * Gets if the node is a SuperExpression.
     * @param node - Node to check.
     */
    static isSuperExpression(node: compiler.Node): node is compiler.SuperExpression {
        return node.getKind() === SyntaxKind.SuperKeyword;
    }

    /**
     * Gets if the node is a SwitchStatement.
     * @param node - Node to check.
     */
    static isSwitchStatement(node: compiler.Node): node is compiler.SwitchStatement {
        return node.getKind() === SyntaxKind.SwitchStatement;
    }

    /**
     * Gets if the node is a SymbolKeyword.
     * @param node - Node to check.
     */
    static isSymbolKeyword(node: compiler.Node): node is compiler.Expression {
        return node.getKind() === SyntaxKind.SymbolKeyword;
    }

    /**
     * Gets if the node is a SyntaxList.
     * @param node - Node to check.
     */
    static isSyntaxList(node: compiler.Node): node is compiler.SyntaxList {
        return node.getKind() === SyntaxKind.SyntaxList;
    }

    /**
     * Gets if the node is a TaggedTemplateExpression.
     * @param node - Node to check.
     */
    static isTaggedTemplateExpression(node: compiler.Node): node is compiler.TaggedTemplateExpression {
        return node.getKind() === SyntaxKind.TaggedTemplateExpression;
    }

    /**
     * Gets if the node is a TemplateExpression.
     * @param node - Node to check.
     */
    static isTemplateExpression(node: compiler.Node): node is compiler.TemplateExpression {
        return node.getKind() === SyntaxKind.TemplateExpression;
    }

    /**
     * Gets if the node is a TemplateHead.
     * @param node - Node to check.
     */
    static isTemplateHead(node: compiler.Node): node is compiler.TemplateHead {
        return node.getKind() === SyntaxKind.TemplateHead;
    }

    /**
     * Gets if the node is a TemplateMiddle.
     * @param node - Node to check.
     */
    static isTemplateMiddle(node: compiler.Node): node is compiler.TemplateMiddle {
        return node.getKind() === SyntaxKind.TemplateMiddle;
    }

    /**
     * Gets if the node is a TemplateSpan.
     * @param node - Node to check.
     */
    static isTemplateSpan(node: compiler.Node): node is compiler.TemplateSpan {
        return node.getKind() === SyntaxKind.TemplateSpan;
    }

    /**
     * Gets if the node is a TemplateTail.
     * @param node - Node to check.
     */
    static isTemplateTail(node: compiler.Node): node is compiler.TemplateTail {
        return node.getKind() === SyntaxKind.TemplateTail;
    }

    /**
     * Gets if the node is a TextInsertableNode.
     * @param node - Node to check.
     */
    static isTextInsertableNode<T extends compiler.Node>(node: T): node is compiler.TextInsertableNode & compiler.TextInsertableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
            case SyntaxKind.Block:
            case SyntaxKind.CaseBlock:
            case SyntaxKind.CaseClause:
            case SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ThisExpression.
     * @param node - Node to check.
     */
    static isThisExpression(node: compiler.Node): node is compiler.ThisExpression {
        return node.getKind() === SyntaxKind.ThisKeyword;
    }

    /**
     * Gets if the node is a ThisTypeNode.
     * @param node - Node to check.
     */
    static isThisTypeNode(node: compiler.Node): node is compiler.ThisTypeNode {
        return node.getKind() === SyntaxKind.ThisType;
    }

    /**
     * Gets if the node is a ThrowStatement.
     * @param node - Node to check.
     */
    static isThrowStatement(node: compiler.Node): node is compiler.ThrowStatement {
        return node.getKind() === SyntaxKind.ThrowStatement;
    }

    /**
     * Gets if the node is a TrueKeyword.
     * @param node - Node to check.
     */
    static isTrueKeyword(node: compiler.Node): node is compiler.BooleanLiteral {
        return node.getKind() === SyntaxKind.TrueKeyword;
    }

    /**
     * Gets if the node is a TryStatement.
     * @param node - Node to check.
     */
    static isTryStatement(node: compiler.Node): node is compiler.TryStatement {
        return node.getKind() === SyntaxKind.TryStatement;
    }

    /**
     * Gets if the node is a TupleTypeNode.
     * @param node - Node to check.
     */
    static isTupleTypeNode(node: compiler.Node): node is compiler.TupleTypeNode {
        return node.getKind() === SyntaxKind.TupleType;
    }

    /**
     * Gets if the node is a TypeAliasDeclaration.
     * @param node - Node to check.
     */
    static isTypeAliasDeclaration(node: compiler.Node): node is compiler.TypeAliasDeclaration {
        return node.getKind() === SyntaxKind.TypeAliasDeclaration;
    }

    /**
     * Gets if the node is a TypeArgumentedNode.
     * @param node - Node to check.
     */
    static isTypeArgumentedNode<T extends compiler.Node>(node: T): node is compiler.TypeArgumentedNode & compiler.TypeArgumentedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:
            case SyntaxKind.ImportType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeAssertion.
     * @param node - Node to check.
     */
    static isTypeAssertion(node: compiler.Node): node is compiler.TypeAssertion {
        return node.getKind() === SyntaxKind.TypeAssertionExpression;
    }

    /**
     * Gets if the node is a TypeElement.
     * @param node - Node to check.
     */
    static isTypeElement(node: compiler.Node): node is compiler.TypeElement {
        switch (node.getKind()) {
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeElementMemberedNode.
     * @param node - Node to check.
     */
    static isTypeElementMemberedNode<T extends compiler.Node>(node: T): node is compiler.TypeElementMemberedNode & compiler.TypeElementMemberedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.TypeLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeLiteralNode.
     * @param node - Node to check.
     */
    static isTypeLiteralNode(node: compiler.Node): node is compiler.TypeLiteralNode {
        return node.getKind() === SyntaxKind.TypeLiteral;
    }

    /**
     * Gets if the node is a TypeNode.
     * @param node - Node to check.
     */
    static isTypeNode(node: compiler.Node): node is compiler.TypeNode {
        switch (node.getKind()) {
            case SyntaxKind.TypePredicate:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.JSDocSignature:
            case SyntaxKind.JSDocTypeExpression:
            case SyntaxKind.ArrayType:
            case SyntaxKind.ConditionalType:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.ExpressionWithTypeArguments:
            case SyntaxKind.FunctionType:
            case SyntaxKind.ImportType:
            case SyntaxKind.IndexedAccessType:
            case SyntaxKind.InferType:
            case SyntaxKind.IntersectionType:
            case SyntaxKind.LiteralType:
            case SyntaxKind.ParenthesizedType:
            case SyntaxKind.ThisType:
            case SyntaxKind.TupleType:
            case SyntaxKind.TypeLiteral:
            case SyntaxKind.TypeReference:
            case SyntaxKind.UnionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeOfExpression.
     * @param node - Node to check.
     */
    static isTypeOfExpression(node: compiler.Node): node is compiler.TypeOfExpression {
        return node.getKind() === SyntaxKind.TypeOfExpression;
    }

    /**
     * Gets if the node is a TypeParameterDeclaration.
     * @param node - Node to check.
     */
    static isTypeParameterDeclaration(node: compiler.Node): node is compiler.TypeParameterDeclaration {
        return node.getKind() === SyntaxKind.TypeParameter;
    }

    /**
     * Gets if the node is a TypeParameteredNode.
     * @param node - Node to check.
     */
    static isTypeParameteredNode<T extends compiler.Node>(node: T): node is compiler.TypeParameteredNode & compiler.TypeParameteredNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.FunctionType:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeReferenceNode.
     * @param node - Node to check.
     */
    static isTypeReferenceNode(node: compiler.Node): node is compiler.TypeReferenceNode {
        return node.getKind() === SyntaxKind.TypeReference;
    }

    /**
     * Gets if the node is a TypedNode.
     * @param node - Node to check.
     */
    static isTypedNode<T extends compiler.Node>(node: T): node is compiler.TypedNode & compiler.TypedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.AsExpression:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UnaryExpression.
     * @param node - Node to check.
     */
    static isUnaryExpression(node: compiler.Node): node is compiler.UnaryExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.CallExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PostfixUnaryExpression:
            case SyntaxKind.PrefixUnaryExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidExpression:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UnaryExpressionedNode.
     * @param node - Node to check.
     */
    static isUnaryExpressionedNode<T extends compiler.Node>(node: T): node is compiler.UnaryExpressionedNode & compiler.UnaryExpressionedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UndefinedKeyword.
     * @param node - Node to check.
     */
    static isUndefinedKeyword(node: compiler.Node): node is compiler.Expression {
        return node.getKind() === SyntaxKind.UndefinedKeyword;
    }

    /**
     * Gets if the node is a UnionTypeNode.
     * @param node - Node to check.
     */
    static isUnionTypeNode(node: compiler.Node): node is compiler.UnionTypeNode {
        return node.getKind() === SyntaxKind.UnionType;
    }

    /**
     * Gets if the node is a UnwrappableNode.
     * @param node - Node to check.
     */
    static isUnwrappableNode<T extends compiler.Node>(node: T): node is compiler.UnwrappableNode & compiler.UnwrappableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UpdateExpression.
     * @param node - Node to check.
     */
    static isUpdateExpression(node: compiler.Node): node is compiler.UpdateExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a VariableDeclaration.
     * @param node - Node to check.
     */
    static isVariableDeclaration(node: compiler.Node): node is compiler.VariableDeclaration {
        return node.getKind() === SyntaxKind.VariableDeclaration;
    }

    /**
     * Gets if the node is a VariableDeclarationList.
     * @param node - Node to check.
     */
    static isVariableDeclarationList(node: compiler.Node): node is compiler.VariableDeclarationList {
        return node.getKind() === SyntaxKind.VariableDeclarationList;
    }

    /**
     * Gets if the node is a VariableStatement.
     * @param node - Node to check.
     */
    static isVariableStatement(node: compiler.Node): node is compiler.VariableStatement {
        return node.getKind() === SyntaxKind.VariableStatement;
    }

    /**
     * Gets if the node is a VoidExpression.
     * @param node - Node to check.
     */
    static isVoidExpression(node: compiler.Node): node is compiler.VoidExpression {
        return node.getKind() === SyntaxKind.VoidExpression;
    }

    /**
     * Gets if the node is a WhileStatement.
     * @param node - Node to check.
     */
    static isWhileStatement(node: compiler.Node): node is compiler.WhileStatement {
        return node.getKind() === SyntaxKind.WhileStatement;
    }

    /**
     * Gets if the node is a WithStatement.
     * @param node - Node to check.
     */
    static isWithStatement(node: compiler.Node): node is compiler.WithStatement {
        return node.getKind() === SyntaxKind.WithStatement;
    }

    /**
     * Gets if the node is a YieldExpression.
     * @param node - Node to check.
     */
    static isYieldExpression(node: compiler.Node): node is compiler.YieldExpression {
        return node.getKind() === SyntaxKind.YieldExpression;
    }

    /**
     * @internal
     */
    static _hasStructure(node: compiler.Node): node is compiler.Node & { getStructure(): Structure; } {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Decorator:
            case SyntaxKind.JSDocComment:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.JsxSpreadAttribute:
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.ExportDeclaration:
            case SyntaxKind.ExportSpecifier:
            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ImportSpecifier:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
            case SyntaxKind.SpreadAssignment:
                return true;
            default:
                return false;
        }
    }
}
